# ç†è®ºç¯‡: Swift/ObjC è¯­è¨€åŸºç¡€

<p align="center"><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/02_Swift_interview_questions/practical.md"><img src="../assets/Swift_theory_Interview_Questions.jpg"></a></p>

Swifté¢è¯•é¢˜å…±åˆ†ä¸ºä¸¤ç¯‡:

- [ã€Šç†è®ºç¯‡: Swift/ObjC è¯­è¨€åŸºç¡€ã€‹](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/02_Swift_interview_questions/theory.md) 
 - [ã€Šå®æˆ˜ç¯‡: iOSé¡¹ç›®å¼€å‘æŠ€èƒ½ã€‹]( https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/02_Swift_interview_questions/practical.md ) 

 æ˜¯æˆ‘è‡ªå·±åœ¨å›½å¤–é¢è¯•æ—¶å‡†å¤‡çš„ç¬”è®°, æ‰€ä»¥å¾ˆå¤šæ˜¯è‹±æ–‡çš„, åç»­æœ‰æ—¶é—´å†ç¿»è¯‘. 

# ç›®å½•

## åˆçº§é¢è¯•é¢˜

## ä»£ç ä¼˜åŒ–é¢˜

1. ä¼˜åŒ–åˆ¤æ–­é¢˜
2. ä»£ç ä¼˜åŒ–

## æ•°æ®ç±»å‹ä¸ç»“æ„

- WHY Swift not ObjC?
- ä»‹ç»ä¸€ä¸‹ Swift ç›¸å…³çš„é‡è¦å˜æ›´äº‹ä»¶
- What is the difference between a struct and a class? è¯·æ¯”è¾ƒ Swift ä¸­çš„ç»“æ„ä½“å’Œç±»çš„ä¸»è¦åŒºåˆ«ï¼Ÿclass å’Œ struct çš„åŒºåˆ«.
- Q: if a struct is an immutable value type, why we can mutate the size property?
- Swift çš„ Copy-on-Write æ˜¯æ€ä¹ˆå®ç°çš„
- What are the basic categories of types in Swift?
- What is a Tuple in Swift?
- Is it possible to return multiple values from a function in Swift? If yes, how?
- ï¬nal æ˜¯ä»€ä¹ˆï¼š
- String ä¸ NSString çš„å…³ç³»ä¸åŒºåˆ«ï¼š
- defer ä½¿â½¤åœºæ™¯ï¼š
- struct åœ¨å †åŒºè¿˜æ˜¯æ ˆåŒºï¼Ÿ
- å±æ€§ä¸­ï¼Œå€¼å±æ€§ï¼Œå’Œè®¡ç®—å±æ€§æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ
- å£°æ˜â¼€ä¸ªåªæœ‰â¼€ä¸ªå‚æ•°æ²¡æœ‰è¿”å›å€¼é—­åŒ…çš„åˆ«å
-  Principle of Dictionary?

## **æ³›å‹ï¼š**

- Q.ä»€ä¹ˆæ˜¯æ³›å‹ï¼Œswiftå“ªäº›åœ°æ–¹ä½¿ç”¨äº†æ³›å‹ï¼Ÿ
- Have you used generics in Swift?
- è¯·è§£é‡Š Swift ä¸­çš„æ³›å‹æ˜¯ä»€ä¹ˆï¼Ÿå¹¶æè¿°ä¸€ä¸‹å®ƒçš„æœ¬è´¨ï¼Ÿ
- *æ³›å‹çš„æœ¬è´¨*
-  What's the difference between `opaque type` and `generic`?


## å†…å­˜ç®¡ç†ã€**æ€§èƒ½ä¼˜åŒ–å’Œè°ƒè¯•ï¼š**

- When do you use static variables in Swift?static å…³é”®å­—å’Œ class å…³é”®å­— ä¿®é¥°çš„ç±»â½…æ³•æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ
- Can you explain the difference between weak and unowned references in Swift?
- What is memory leak ? how to solve?

## æ•°æ®å¤„ç†ã€è¯­è¨€å®‰å…¨ã€ **è®¿é—®æƒé™ï¼š**

- Please implement a convenience init method for a subclass.
- Swift çš„å®‰å…¨æ€§
- è¯·è§£é‡Š Swift ä¸­çš„è®¿é—®æƒé™å¦‚ä½•è®¾ç½®ï¼Œä»¥åŠä¸åŒè®¿é—®çº§åˆ«ä¹‹é—´çš„åŒºåˆ«ï¼Ÿ
- Swift Try catch çš„åŸç†ï¼Ÿ
- Swift çš„è®¡ç®—å±æ€§ã€å­˜å‚¨å±æ€§ã€æ‡’åŠ è½½
- How do you filter an array of instances to extract a specific property?
- The time complexity of the map, filter, and reduce?
- *Sequence / â¾¼é˜¶å‡½æ•° / Collection*
- æ··ç¼–è¿‡ç¨‹ä¸­é‡åˆ°çš„ Crash

## é¢å‘å¯¹è±¡

- Swift å¯¹è±¡å’Œ OC å¯¹è±¡çš„åŒºåˆ«
- What is polymorphism?
- ä¸é€šè¿‡ç»§æ‰¿ï¼Œä»£ç å¤â½¤ / å…±äº«çš„â½…å¼æœ‰å“ªäº›ï¼Ÿ
- çˆ¶ç±»çš„åˆ†ç±»ä¸­å†™äº†ä¸€ä¸ªæ–¹æ³•, å­ç±»èƒ½å¦ç›´æ¥è°ƒç”¨ã€‚å‘ŠçŸ¥åŸå› ã€‚

## **é¢å‘åè®®ç¼–ç¨‹ï¼š**

- What is a protocol and how can we benefit from it?
- Can we add a property in a protocol? Can we put property in the protocol in Swift? And can we share the same property value through protocol in Swift?
- è¯·æè¿°ä»€ä¹ˆæ˜¯é¢å‘åè®®ç¼–ç¨‹ï¼ˆProtocol-oriented Programmingï¼‰ï¼Œå¹¶ä¸¾ä¾‹è¯´æ˜å…¶åœ¨Swiftä¸­å¦‚ä½•å®ç°ï¼Ÿ
- Swift çš„åè®®å’Œ OC çš„åè®®æœ‰ä»€ä¹ˆåŒºåˆ«
- **What is protocol extension? Why Swift called as Protocol Oriented Language?**

## **é—­åŒ…ï¼š**

- Have you worked with closures in Swift?
- When would you use a closure?
- What are closures in Swift?
- è¯·è§£é‡Š Swift ä¸­çš„é—­åŒ…æ˜¯ä»€ä¹ˆï¼Œå¹¶æè¿°ä¸€ä¸ªé—­åŒ…åœ¨å®é™…ç¼–ç¨‹ä¸­çš„åº”ç”¨åœºæ™¯ï¼Ÿ
- Swift çš„é—­åŒ…ï¼ˆClosureï¼‰ å’Œ OC çš„ Block
- è¯·è§£é‡Š Swift ä¸­çš„é—­åŒ…æ˜¯ä»€ä¹ˆï¼Œå¹¶æè¿°ä¸€ä¸ªé—­åŒ…åœ¨å®é™…ç¼–ç¨‹ä¸­çš„åº”ç”¨åœºæ™¯ï¼Ÿ


## **å¯é€‰ç±»å‹ï¼š**

- What are the ways to unwrap an optional value in Swift?
- How do you unwrap optionals?
- Swift ä¸­çš„å¯é€‰å‹æ˜¯ä»€ä¹ˆï¼Ÿå®ƒçš„æœ¬è´¨æ˜¯ä»€ä¹ˆï¼Ÿ
- What is the difference between if let and guard let?
- *Optionalï¼ˆå¯é€‰å‹ï¼‰ æ˜¯â½¤ä»€ä¹ˆå®ç°çš„*

## **lazy å…³é”®å­—ï¼š**

- è¯·è§£é‡Š Swift ä¸­çš„ lazy å…³é”®å­—æ˜¯æ€ä¹ˆå®ç°çš„ï¼Ÿåœ¨ä»€ä¹ˆæƒ…å†µä¸‹ä¼šä½¿ç”¨å®ƒï¼Ÿ
- *lazy load æ˜¯æ€ä¹ˆå®ç°çš„ï¼Ÿ*

# æ­£æ–‡

## åˆçº§é¢è¯•é¢˜
![1](assets/1.png)

Answer: C

A tuple in Swift is defined as: let vals = 
("val", 1)


A valid dictionary in Swift should be defined as: let vals = ["val": 1]

A valid set in Swift should be defined as: let vals: Set = ["val", "1"]


![2](assets/2.png)


**Answer:** A) Extensions cannot add properties. In Swift, extensions can add computed instance properties and computed type properties, but they cannot add stored instance properties, or property observers such as `willSet` and `didSet`. Therefore, the code snippet you provided is incorrect. 

A corrected version using computed properties could look like this:
```swift
extension String {
    var firstLetter : Character {
        get {
            return self.count > 0 ? self[self.startIndex] : nil
        }
        set {
            // Replace first character of string, or add if none exists
            if self.count > 0 {
                self.replaceSubrange(self.startIndex...self.startIndex, with: String(newValue))
            } else {
                self.append(newValue)
            }
        }
    }
}
```


![](assets/16918516162699.jpg)

Answer: B.

![3](assets/3.png)

**Answer:** C) Dictionary<String, Any>



In Swift, when you define a `typealias`, it creates a new name for an existing type. However, when you print the type using `type(of:)`, it shows the original type, not the typealias name.

but it is better to write the code in this way:

```swift
typealias Thing = [String: Any]
var stuff: Thing = [:]
print(type(of: stuff))
```

it is better to init the stuff before you use it, but it won't be a big problem.

The output will indeed be `Dictionary<String, Any>`. The `type(of:)` function will print the actual type of `stuff`, which is `Dictionary<String, Any>`, not the `typealias` name `Thing`. 


![4](assets/4.png)

**Answer:** A) ABC. After executing the code, the value of `test` will be "ABC". The variable `vr` is defined as a tuple with named elements. The tuple has two elements: `name` and `val`. In Swift, you can access tuple elements using dot syntax followed by the index of the element. The first element in a tuple has an index of 0, the second element has an index of 1, and so on. In this case, `vr.0` refers to the first element of the tuple, which is `"ABC"`. Therefore, the value of `test` will be `"ABC"`.


![5](assets/5.png)


**Answer:** C) string?. To declare an optional String in Swift, you use the syntax `String?`. The question mark `?` indicates that the variable can either contain a String value or be `nil`, which means it is optional. For example:
```swift
var optionalString: String?
```
In this case, `optionalString` is an optional variable that can hold a String value or be `nil`.


![6](assets/6.png)


**Answer:** D) either a designated or another convenience initializer. In Swift, a convenience initializer must call another initializer within the same class, whether it is a designated initializer or another convenience initializer. It ensures that the complete initialization chain is followed, allowing the designated initializer at the top of the chain to initialize all properties.

To clarify, the designated initializer is the primary initializer responsible for initializing all properties of a class, and it must eventually call a designated initializer from its superclass to ensure all properties throughout the inheritance chain are initialized.

On the other hand, convenience initializers are secondary initializers that provide additional ways to create an instance. They must call a designated initializer or another convenience initializer from the same class before customizing the instance if needed. This guarantees that all properties are initialized properly regardless of the initializer used to create the instance.


![7](assets/7.png)
The correct answer is:

**Answer:** C) "t"

When the provided Swift code is executed, it will iterate over each character in the string "t" using the `forEach` method. The closure `{ (char) in print(char) }` is called for each character, and it will print each character to the console. In this case, there's only one character in the string, which is "t", so "t" will be printed to the console.

Output:
```
t
```

![8](assets/8.PNG)


**Answer:** B) Protocol functions cannot have implementations. The code is incorrect because protocol functions cannot have default implementations. Protocols are used to define a set of methods or properties that must be implemented by conforming classes or structures. However, protocol functions cannot provide a default implementation within the protocol definition itself.

To fix the code, remove the implementation of the `add` function from the protocol definition, like this:
```swift
protocol iTeaTime {
    func add(x1: Int, x2: Int) -> Int
}
```
Now, any class or structure that conforms to the `iTeaTime` protocol will be required to provide its own implementation of the `add` function.


![9](assets/9.png)

**Answer:** A) executed on the main queue. The `DispatchQueue.main.async` method takes a block of code (closure) and schedules it to be executed asynchronously on the main queue. In iOS, the main queue is responsible for handling UI updates and user interactions. By using `DispatchQueue.main.async`, you ensure that the code inside the block will be executed on the main thread, allowing you to safely update the UI elements from that block.

For example:
```swift
DispatchQueue.main.async {
    // Code here will be executed on the main queue
    // You can safely update UI elements from this block
}
```

## ä»£ç ä¼˜åŒ–é¢˜

## Q: ä»£ç é¢˜:

```
class Person {
    var name: String

    init(name: String) {
        self.name = name
    }
}

struct Company {
    var size: Int
    var manager: Person

    mutating func increaseSize() {
        self = Company(size: size + 1, manager: manager)
    }

    mutating func increaseSizeV2() {
        size += 1
    }
}

var companyA = Company(size: 100, manager: Person(name: "Peter"))

var companyB = companyA
companyA.size = 150  // if a struct is an immutable value type, why we can mutate the size property?
print(companyA.size) // ? question1
print(companyB.size) // ? question2

companyA.manager.name = "Bob"
print(companyA.manager.name) // ? question3
print(companyB.manager.name) // ? question4

companyA.increaseSize()
print(companyA.size) // ? question5
companyA.increaseSizeV2()
print(companyA.size) // ? question6

```

A:

```
class Person {
    var name: String

    init(name: String) {
        self.name = name
    }
}

struct Company {
    var size: Int
    var manager: Person

    mutating func increaseSize() {
        self = Company(size: size + 1, manager: manager)
    }

    mutating func increaseSizeV2() {
        size += 1
    }
}

var companyA = Company(size: 100, manager: Person(name: "Peter"))

var companyB = companyA
companyA.size = 150  // if a struct is an immutable value type, why we can mutate the size property?
print(companyA.size) // ? 150
print(companyB.size) // ? 150

companyA.manager.name = "Bob"
print(companyA.manager.name) // ? Bob
print(companyB.manager.name) // ? Bob

companyA.increaseSize()
print(companyA.size) // ? 151
companyA.increaseSizeV2()
print(companyA.size) // ? 152
```

```

ç­”æ¡ˆ

question1:150
question2:100
question3:Bob
question4:Bob
question5:151
question6:152

```


æ³¨æ„ ä¸ copy on write è¾¨åˆ«  

## ä»£ç é¢˜
![5](assets/5.jpg)

[https://chat.openai.com/share/29d0a44a-26cc-4685-a68a-92a134be6d3e](https://chat.openai.com/share/29d0a44a-26cc-4685-a68a-92a134be6d3e)


## é¢˜ç›®

å¦‚æœ carsInDriving çš„æ•°é‡å¾ˆå¤§ï¼Œå¦‚ä½•æ”¹è¿›è¿™æ®µä»£ç ï¼Ÿ

```swift
struct Car {
    var driving = false
}

class Test {
    var cars: [Car] = []

    var carsInDriving: [Car] {
        cars.filter({$0.driving})
    }

    func loop() {
        for car in carsInDriving {
            // ...
        }
    }
}

```

## ç­”æ¡ˆ

**åˆå§‹**æ–¹æ¡ˆ **ï¼š**

```swift
struct Car {
    var driving = false
}

class Test {
    var cars: [Car] = []

    var carsInDriving: [Car] {
        cars.filter({$0.driving})
    }

    func loop() {
        for car in carsInDriving {
            // ...
        }
    }
}

```

åœ¨è¿™æ®µä»£ç ä¸­ï¼Œ`carsInDriving` çš„ getter æ–¹æ³•æœ‰ O(n) çš„æ—¶é—´å¤æ‚åº¦ï¼Œå…¶ä¸­ n æ˜¯ `cars` æ•°ç»„çš„å…ƒç´ æ•°é‡ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬éœ€è¦æ£€æŸ¥æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ ä»¥ç¡®å®šå®ƒæ˜¯å¦åœ¨é©¾é©¶ã€‚ç„¶è€Œï¼Œè¿™ä¸ªè¿‡æ»¤æ“ä½œåªä¼šåœ¨æ¯æ¬¡è®¿é—® `carsInDriving` æ—¶æ‰§è¡Œä¸€æ¬¡ï¼Œå¹¶ä¸”ç»“æœä¸ä¼šè¢«å­˜å‚¨ï¼Œæ‰€ä»¥åœ¨åŒä¸€ä¸ª `get` è°ƒç”¨ä¸­ï¼Œå¤æ‚åº¦æ˜¯ O(n)ã€‚`loop` æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿæ˜¯ O(n)ï¼Œè¿™æ˜¯å› ä¸ºå®ƒåœ¨æ¯æ¬¡è°ƒç”¨æ—¶éƒ½éœ€è¦é‡æ–°è®¡ç®— `carsInDriving`ï¼Œç„¶åéå†æ‰€æœ‰æ­£åœ¨é©¾é©¶çš„è½¦ã€‚

è¿™é‡Œçš„æ•°ç»„ä¸å»ºè®®æ¢æˆset. setä¸»è¦ç”¨äºå»é‡çš„åœºæ™¯, è€Œä¸”setæ˜¯æ— åºçš„.

ä¼˜åŒ–æ–¹æ¡ˆ1**. ä¼˜åŒ–åçš„ä»£ç ï¼š**

```swift
struct Car {
    var driving = false
}

class Test {
    private var _carsInDriving: Set<Car>? = nil
    var cars: [Car] {
        didSet {
            _carsInDriving = nil
        }
    }

    var carsInDriving: Set<Car> {
        if let carsInDriving = _carsInDriving {
            return carsInDriving
        } else {
            let carsInDriving = Set(cars.filter({$0.driving}))
            _carsInDriving = carsInDriving
            return carsInDriving
        }
    }

    func loop() {
        for car in carsInDriving {
            // ...
        }
    }
}

```

åœ¨è¿™æ®µä»£ç ä¸­ï¼Œ`carsInDriving` çš„ getter æ–¹æ³•åœ¨ `_carsInDriving` ä¸ºç©ºæ—¶å…·æœ‰ O(n) çš„æ—¶é—´å¤æ‚åº¦ï¼Œå¦åˆ™å®ƒå…·æœ‰ O(1) çš„æ—¶é—´å¤æ‚åº¦ã€‚è¿™æ˜¯å› ä¸ºæˆ‘ä»¬åªåœ¨ `_carsInDriving` ä¸ºç©ºæ—¶è®¡ç®— `carsInDriving`ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åœ¨ `_carsInDriving` ä¸­ã€‚è¿™æ ·å°±åˆ›å»ºäº†ä¸€ä¸ªç¼“å­˜æœºåˆ¶ã€‚`loop` æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä»ç„¶æ˜¯ O(n)ï¼Œä½†å¦‚æœ `carsInDriving` è¢«å¤šæ¬¡è°ƒç”¨ï¼Œå¹¶ä¸” `cars` æ²¡æœ‰å‘ç”Ÿæ”¹å˜ï¼Œé‚£ä¹ˆé™¤äº†ç¬¬ä¸€æ¬¡è®¡ç®—å¤–ï¼Œå…¶ä½™çš„è°ƒç”¨éƒ½å…·æœ‰ O(1) çš„æ—¶é—´å¤æ‚åº¦ã€‚

**ä¼˜åŒ–æ–¹æ¡ˆ2ï¼š**

```swift
struct Car {
    var driving = false
}

class Test {
    var cars: [Car] = []

    func loop() {
        for car in cars where car.driving {
            // ...
        }
    }
}

```

åœ¨ä½ çš„ä»£ç ä¸­ï¼Œ`loop` æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(n)ï¼Œè¿™æ˜¯å› ä¸ºä½ ç›´æ¥åœ¨ `loop` æ–¹æ³•ä¸­éå† `cars`ï¼Œå¹¶åœ¨éå†æ—¶è¿‡æ»¤å‡ºæ­£åœ¨é©¾é©¶çš„è½¦è¾†ã€‚è¿™ä¸ªæ–¹æ³•çš„ä¼˜ç‚¹æ˜¯å®ƒåœ¨æ¯æ¬¡è°ƒç”¨æ—¶éƒ½å¯¹ `cars` è¿›è¡Œå®æ—¶çš„è¿‡æ»¤ï¼Œæ— éœ€ä¾èµ–é¢å¤–çš„çŠ¶æ€ï¼Œä½†ç¼ºç‚¹æ˜¯æ¯æ¬¡è°ƒç”¨ `loop` æ—¶éƒ½éœ€è¦é‡æ–°è¿‡æ»¤ `cars`ã€‚

æ€»ç»“èµ·æ¥ï¼Œå“ªç§æ–¹æ³•æ›´å¥½å–å†³äºä½ çš„ä½¿ç”¨æƒ…å†µã€‚å¦‚æœ `cars` é›†åˆç»å¸¸å˜åŒ–ï¼Œæˆ–è€…æˆ‘ä»¬ä¸éœ€è¦é¢‘ç¹åœ°è®¿é—®æ­£åœ¨é©¾é©¶çš„è½¦è¾†ï¼Œé‚£ä¹ˆä½ çš„æ–¹æ³•å¯èƒ½æ›´å¥½ã€‚å¦‚æœæˆ‘ä»¬éœ€è¦é¢‘ç¹åœ°è®¿é—®æ­£åœ¨é©¾é©¶çš„è½¦è¾†ï¼Œä½† `cars` é›†åˆä¸ç»å¸¸å˜åŒ–ï¼Œé‚£ä¹ˆç¬¬äºŒç§ä¼˜åŒ–åçš„æ–¹æ³•å¯èƒ½æ›´å¥½ã€‚

æ–¹æ¡ˆçš„å¦ä¸€ç§å†™æ³•:

![](../assets/16912026477007.jpg)

let result = persons.lazy.filter { $0.age >= 18}.map{ $0.name }
print(Array(result))
é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ç†è§£`lazy`åœ¨Swiftä¸­çš„å«ä¹‰ã€‚å½“æˆ‘ä»¬åœ¨é›†åˆç±»å‹ï¼ˆå¦‚æ•°ç»„ï¼‰ä¸Šè°ƒç”¨`lazy`å±æ€§æ—¶ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ªç‰¹æ®Šçš„é›†åˆè§†å›¾ï¼Œè¯¥è§†å›¾ä¼šåœ¨éœ€è¦æ—¶æ‰è¿›è¡Œè®¡ç®—ï¼Œä»è€Œå¯èƒ½æé«˜æ€§èƒ½ã€‚è¿™ç§æ‡’æƒ°çš„è¡Œä¸ºå¯¹äºæ˜‚è´µçš„è®¡ç®—æ“ä½œï¼ˆå¦‚æˆ‘ä»¬çš„`.filter`æ“ä½œï¼‰å¯èƒ½éå¸¸æœ‰ç”¨ã€‚

```swift
struct Car {
    var driving = false
}

class Test {
    var cars: [Car] = []

    func loop() {
        for car in cars.lazy.filter({$0.driving}) {
            // ...
        }
    }
}

```

åœ¨è¿™ä¸ªç‰ˆæœ¬ä¸­ï¼Œæˆ‘ä»¬åœ¨`loop`å‡½æ•°å†…éƒ¨ä½¿ç”¨äº†`lazy.filter`ã€‚è¿™ä¼šåˆ›å»ºä¸€ä¸ªå¯ä»¥å»¶è¿Ÿè®¡ç®—å…¶è¿‡æ»¤æ“ä½œçš„é›†åˆè§†å›¾ã€‚ç”±äºè¿‡æ»¤æ“ä½œæ˜¯æ‡’æƒ°çš„ï¼Œæ‰€ä»¥åªæœ‰åœ¨å¾ªç¯ä¸­å®é™…éœ€è¦æ—¶ï¼Œè¿‡æ»¤æ“ä½œæ‰ä¼šæ‰§è¡Œã€‚è¿™ç§æ–¹æ³•æœ‰åŠ©äºé¿å…åˆ›å»ºä¸€ä¸ªæ–°çš„æ•°ç»„ï¼ˆåªåŒ…å«æ­£åœ¨é©¾é©¶çš„è½¦è¾†ï¼‰ï¼Œä»è€Œå‡å°‘å†…å­˜ä½¿ç”¨å¹¶æé«˜æ€§èƒ½ï¼Œå°¤å…¶æ˜¯åœ¨`cars`æ•°ç»„éå¸¸å¤§çš„æƒ…å†µä¸‹ã€‚

é™¤äº†lazy, è¿˜åŠ äº†ä¸€ä¸ªæš‚å­˜. ç©ºé—´æ¢æ—¶é—´.

æ–¹æ¡ˆ3: 

```swift
struct Car {
    var driving = false
}

class Test {
    var cars: [Car] = []

    lazy var carsInDriving: [Car] = {
        cars.filter({$0.driving})
    }()

    func loop() {
        for car in carsInDriving {
            // You can do something with each driving car here.
        }
    }
}

```

åœ¨è¿™ä¸ªç‰ˆæœ¬ä¸­ï¼Œæˆ‘ä»¬å°† `Dog` ç»“æ„ä½“æ›¿æ¢ä¸º `Car`ï¼Œå¹¶å°† `running` å±æ€§æ›¿æ¢ä¸º `driving`ï¼Œè¿™æ · `driving` å°±è¡¨ç¤ºè¿™è¾†è½¦æ˜¯å¦æ­£åœ¨è¡Œé©¶ã€‚ç±» `Test` ä¸­çš„å…¶ä»–éƒ¨åˆ†ä¹Ÿè¿›è¡Œäº†ç›¸åº”çš„ä¿®æ”¹ã€‚ç°åœ¨ `loop` å‡½æ•°ä¼šéå†æ‰€æœ‰æ­£åœ¨é©¾é©¶çš„è½¦è¾†ã€‚

æ–¹æ¡ˆ4çš„å¦ä¸€ç§å†™æ³•

```swift
struct Car {
    var driving = false
}

class Test {
    var cars: [Car] = []

    lazy var carsInDriving: LazySequence<[Car]> = {
        cars.lazy.filter({$0.driving})
    }()

    func loop() {
        for car in carsInDriving {
            // ...
        }
    }
}

```

åœ¨è¿™ä¸ªç‰ˆæœ¬ä¸­ï¼Œ`carsInDriving`æ˜¯ä¸€ä¸ª`lazy`å±æ€§ï¼Œå¹¶ä¸”æ˜¯ä¸€ä¸ª`LazySequence`ã€‚å½“ä½ ç¬¬ä¸€æ¬¡è®¿é—®`carsInDriving`ï¼ˆåœ¨è¿™é‡Œæ˜¯åœ¨`loop`å‡½æ•°ä¸­ï¼‰æ—¶ï¼Œå®ƒå°†è®¡ç®—å…¶å€¼å¹¶å°†ç»“æœå­˜å‚¨èµ·æ¥ã€‚ä¸æ–¹æ³•Aç›¸æ¯”ï¼Œè¿™ç§æ–¹æ³•å¯ä»¥é˜²æ­¢åœ¨æ¯æ¬¡è°ƒç”¨`loop`å‡½æ•°æ—¶éƒ½è¿›è¡Œè¿‡æ»¤æ“ä½œã€‚ä½†æ˜¯ï¼Œå¦‚æœ`cars`æ•°ç»„ä¸­è½¦è¾†çš„`driving`çŠ¶æ€ç»å¸¸å‘ç”Ÿå˜åŒ–ï¼Œé‚£ä¹ˆè¿™ç§æ–¹æ³•å¯èƒ½ä¸èƒ½åæ˜ æœ€æ–°çš„çŠ¶æ€ï¼Œå› ä¸º`carsInDriving`åœ¨ç¬¬ä¸€æ¬¡è®¡ç®—åå°±è¢«å­˜å‚¨äº†èµ·æ¥ï¼Œä¸ä¼šå†æ›´æ–°ã€‚

æ‰€ä»¥ï¼Œå“ªç§æ–¹æ³•æ›´å¥½å–å†³äºå…·ä½“çš„ä½¿ç”¨åœºæ™¯ã€‚å¦‚æœä½ çš„`cars`æ•°ç»„ç»å¸¸å‘ç”Ÿå˜åŒ–ï¼Œé‚£ä¹ˆæ–¹æ³•Aå¯èƒ½æ›´å¥½ï¼Œå› ä¸ºå®ƒä¼šåœ¨æ¯æ¬¡æ‰§è¡Œ`loop`æ—¶åæ˜ æœ€æ–°çš„çŠ¶æ€ã€‚ç„¶è€Œï¼Œå¦‚æœ`cars`æ•°ç»„åŸºæœ¬ä¸å˜ï¼Œä½†ä½ éœ€è¦é¢‘ç¹åœ°æ‰§è¡Œ`loop`ï¼Œé‚£ä¹ˆæ–¹æ³•Bå¯èƒ½æ›´å¥½ï¼Œå› ä¸ºå®ƒå¯ä»¥é¿å…ä¸å¿…è¦çš„é‡å¤è®¡ç®—ã€‚


## WHY Swift not ObjC?

[https://chat.openai.com/share/eef4d254-7ff5-4b37-b58e-431fb10e4e97](https://chat.openai.com/share/eef4d254-7ff5-4b37-b58e-431fb10e4e97)

![](../assets/16911993105830.jpg)

![](../assets/16911993775698.jpg)

![](../assets/16911993939541.jpg)

![](../assets/16911994019477.jpg)


## ä»‹ç»ä¸€ä¸‹ Swift ç›¸å…³çš„é‡è¦å˜æ›´äº‹ä»¶

## Swift â¼¤äº‹è®°

1ï¼‰ABI ç¨³å®š
swift 5 2019 å‘å¸ƒï¼Œ ABI ç¨³å®šï¼Œä¸ä¼šè¿‡â¼¤çš„å¢åŠ åŒ…ä½“ç§¯äº†ï¼›

Swift æ¼”è¿›ä¹‹è·¯
æœ¬ç¯‡ä¸»è¦æ˜¯å¯¹[ã€ŠAç«™ çš„ Swift å®è·µã€‹]
([https://ming1016.github.io/202](https://ming1016.github.io/202)[https://mp.weixin.qq.com/s/z4MKCSNXu7kBY7uU8KC1Aw](https://mp.weixin.qq.com/s/z4MKCSNXu7kBY7uU8KC1Aw)

[https://ming1016.github.io/2022/02/10/swift-evolutionary-path/](https://ming1016.github.io/2022/02/10/swift-evolutionary-path/)

2ï¼‰SwiftUIã€Combineã€Concurrencyï¼ˆéƒ½å¼€å§‹äº iOS 13+ï¼‰
1ã€SwiftUI
2ã€Combine
Combine æ˜¯â¼€ç§å“åº”å¼ç¼–ç¨‹èŒƒå¼ï¼Œé‡‡â½¤å£°æ˜å¼çš„ Swift APIã€‚
Combine çš„ä¸‰ä¸ªæ ¸â¼¼æ¦‚å¿µ - å‘å¸ƒè€… - è®¢é˜…è€… - æ“ä½œç¬¦ï¼š

```swift
let pA = Just(0)
let _ = pA.sink { v in
Â  Â  print("pA is: \(v)")
}

let pB = [7,90,16,11].publisher
let _ = pB

Â  Â  .sink { v in

Â  Â  Â  Â  print("pB: \(v)")
Â  Â  }

class AClass {
Â  Â  var p: Int = 0 {
Â  Â  Â  Â  didSet {
Â  Â  Â  Â  Â  Â  print("property update to \(p)")
Â  Â  Â  Â  }
Â  Â  }
}
let o = AClass()

let _ = pB.assign(to: \.p, on: o)
```

3ã€Concurrency

Swift Concurrency çš„å®ç°â½¤äº†Â LLVMçš„åç¨‹ æŠŠ async/await å‡½æ•°è½¬æ¢ä¸ºåŸºäºå›è°ƒçš„ä»£ç 
Swift Concurrency ä¸æ˜¯å»ºâ½´åœ¨ GCD ä¸Šï¼Œâ½½æ˜¯ä½¿â½¤çš„â¼€ä¸ªå…¨æ–°çš„çº¿ç¨‹æ± ã€‚

## What is the difference between a struct and a class in Swift?

[https://chat.openai.com/share/9d33c809-8034-4ef2-a54b-5e6b20bc4178](https://chat.openai.com/share/9d33c809-8034-4ef2-a54b-5e6b20bc4178)

In Swift,Â **Array, String, and Dictionary are all value types**. They behave much like a simple int value in C, acting as a unique instance of that data. Reference Type : Copying a reference on the other hand implicitly creates a shared instance.

## struct VS class?
![](../assets/16911997093380.jpg)


[Getting to Know Enum, Struct and Class Types in Swift](https://www.kodeco.com/7320-getting-to-know-enum-struct-and-class-types-in-swift)

`class`Â performing faster thanÂ `struct`Â or the other way around

## class å’Œ struct çš„åŒºåˆ«

1ï¼‰class æ˜¯å¼•â½¤ç±»å‹ï¼Œstruct æ˜¯å€¼ç±»å‹ï¼›

2ï¼‰å¦‚æœâ¾¥â¾¯å¯¹è±¡è¾ƒå°‘ï¼Œä½¿â½¤ struct â½è¾ƒèŠ‚çœæ€§èƒ½ã€‚

3ï¼‰struct ä¸å¯è¢«ç»§æ‰¿ -ï¼ˆå¦å¤–åŠ â¼€æ¡ enum ä¹Ÿæ˜¯å€¼ç±»å‹ï¼‰

4ï¼‰struct â¾¥çš„ classï¼Œå³ä½¿ struct å¤åˆ¶äº†ï¼Œå®ƒä¹Ÿæ˜¯å¼•â½¤ç±»å‹ ï¼›
é‡è¦ï¼šä¾‹å¤–ï¼Œé—­åŒ…â¾¥ä½¿â½¤ Struct æ˜¯â¼€ä»½å¼•â½¤ï¼Œé™¤â¾®æ˜ç¡®çš„ copy â¼€ä»½ï¼›

5ï¼‰â½¬å‰ Swift çš„ Foudation åŸºæœ¬å…¨â½¤ Struct å®ç°äº†ï¼ŒåŸå› æ˜¯ï¼Ÿ
Why Choose Struct Over Class? æ¥â¾ƒ StackOverFlow 

[Why Choose Struct Over Class?](https://stackoverflow.com/questions/24232799/why-choose-struct-over-class)

1ã€å†…å­˜ä¸Šï¼Œå€¼å¼•â½¤åœ¨æ ˆåŒºï¼Œå¼•â½¤ç±»å‹åœ¨å †åŒºè¿›â¾å­˜å‚¨å’Œæ“ä½œï¼Œæ ˆåŒºçš„è¿â¾æ•ˆç‡æ›´â¾¼ï¼›
2ã€å¤šçº¿ç¨‹çš„ç¯å¢ƒä¸‹æ›´å®‰å…¨ï¼Œå†™æ—¶å¤åˆ¶çš„æ“ä½œå¯ä»¥æœ€â¼¤é™åº¦çš„ä¼˜åŒ–æ€§èƒ½ï¼Œä¹Ÿä¸â½¤æ‹…â¼¼å†…å­˜æ³„éœ²ï¼ˆäº’ç›¸å¼•â½¤ï¼‰ï¼›
3ã€å¼•ç”³çŸ¥è¯†ï¼šä¸ºä»€ä¹ˆæ ˆåœ¨â¾¼åœ°å€ï¼Ÿè¿™æ ·æ ˆçš„èµ·å§‹ä½ç½®å›ºå®šï¼Œæ‰©å±•çš„æ—¶å€™ä¸éœ€è¦è¿ç§»æ•´ä¸ªæ ˆçš„æ•°æ®ã€‚

å…³äºä¸ºä»€ä¹ˆæ ˆåŒºæ“ä½œâ½å †åŒºæ“ä½œå¿«ï¼Œå¯ä»¥çœ‹è¿™ç¯‡â½‚ç« ï¼šSwift å¼€å‘ä¸­ï¼Œä¸ºä»€ä¹ˆè¦è¿œç¦» Heapï¼Ÿ

[https://www.jianshu.com/p/aca50c5a9d64](https://www.jianshu.com/p/aca50c5a9d64) 

[Swift å¼€å‘ä¸­ï¼Œä¸ºä»€ä¹ˆè¦è¿œç¦» Heapï¼Ÿ](https://www.jianshu.com/p/aca50c5a9d64)

Swift çš„å †åŒºæ˜¯ä½¿â½¤åŒå‘é“¾è¡¨è¿›â¾å†…å­˜åˆ†é…çš„ï¼Œ

|  | heap | stack |
| --- | --- | --- |
| ç»“æ„ | Swift åŸºäºåŒå‘é“¾è¡¨ |  æ ˆ |
| ç‰¹ç‚¹ |  â¼¿åŠ¨åˆ†é…â¼¤â¼©ã€éšæ—¶é‡Šæ”¾ç©ºé—´ï¼Œæ•°æ®è¿›å‡ºâ½†åº | â¾ƒåŠ¨åˆ†é…â¼¤â¼©ï¼Œâ¾ƒåŠ¨é‡Šæ”¾å†…å­˜ï¼Œæ•°æ®å…ˆè¿›åå‡º
| æ“ä½œ  | æŸ¥è¯¢ä¹‹ååˆ†é…/é‡Šæ”¾ï¼Œä¹‹åå†åšæ•´åˆï¼Œå¤æ‚åº¦â¾¼  | ä¾é æ ˆåº•æŒ‡é’ˆç§»åŠ¨æ¥åˆ†é…/é‡Šæ”¾ï¼Œå¤æ‚åº¦ä½
| å¯¹è±¡  | å¼•â½¤ç±»å‹å¦‚ classã€‚å¼•â½¤ è®¡æ•°ï¼Œå˜é‡ç±»å‹ç­‰ä¿¡æ¯ | å€¼ç±»å‹å¦‚ struct, enum, Intã€‚å‡½æ•°è¿”å›å€¼ï¼Œå±€éƒ¨å˜é‡
| åœºæ™¯  | C ä¸­çš„ malloc å’Œ free æ“ä½œï¼Œjava ä¸­çš„garbage collectionï¼ŒiOS ä¸­çš„MRCã€ARC | é€‚â½¤äºæ’¤é”€ã€ä¿å­˜æ“ä½œ |
| çº¿ç¨‹ | å…±äº«ï¼Œå¤šçº¿ç¨‹ä¸å®‰å…¨  | ç‹¬äº«ï¼Œå¤šçº¿ç¨‹å®‰å…¨ |

copy on write â»…ä¸‹â¾¯çš„è¯´æ˜ï¼›

## Q: if a struct is an immutable value type, why we can mutate the size property?

A: copy on write

[Handling Mutable Structs in Swift](https://anshul-vyas380.medium.com/handling-mutable-structs-in-swift-7b95add387d)

mutating å…³é”®è¯çš„å«ä¹‰

```jsx
				struct Mutable {
            var x: Int;
            mutating func Mutate() -> Int {
                x = x + 1;
                return x;
            }
        }
        var mutable = Mutable(x: 0)
        print(mutable.Mutate())
        print(mutable.Mutate())
        print(mutable.Mutate())
```

There are a number of things this program could do. Does it:

âœ…1) Print 1, 2, 3 -- because m is readonly, but the "readonly" only applies to m, not to its contents.
âŒ2) Print 0, 0, 0 -- because m is readonly, x cannot be changed. It always has its default value of zero.
âŒ3) Throw an exception at runtime, when the attempt is made to mutate the contents of a readonly field.
âŒ4) Do something else

In class, all func are mutating. But for struct and enum we need to specify.

[Mutating function inside class](https://stackoverflow.com/a/46460684/3395008)

[Does swift copy on write for all structs?](https://stackoverflow.com/a/43493749/3395008)

åœ¨SwiftUIä¸­çš„ä½“ç°:

```
struct Point {
   var x:Float = 0
}

var p1 = Point()
var p2 = p1 //p1 and p2 share the same data under the hood
p2.x += 1 //p2 now has its own copy of the data
```

struct æ˜¯èµ‹å€¼ï¼Œ classæ˜¯å¼•ç”¨

åœ¨struct çš„[è®¡ç®—å±æ€§](https://so.csdn.net/so/search?q=%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7&spm=1001.2101.3001.7020)ï¼ˆcomputed propertyï¼‰é‡Œï¼Œä¸å…è®¸æ”¹å˜æˆå‘˜å˜é‡

![](../assets/16911994188320.jpg)


åŠ ä¸ŠÂ **@State å°±å¯ä»¥æ”¹å˜äº†**

å‚è€ƒï¼š

[ç”¨ç‹€æ…‹è¨­è¨ˆ SwiftUI ç•«é¢ â€” èªè­˜ State property](https://medium.com/%E5%BD%BC%E5%BE%97%E6%BD%98%E7%9A%84-swift-ios-app-%E9%96%8B%E7%99%BC%E5%95%8F%E9%A1%8C%E8%A7%A3%E7%AD%94%E9%9B%86/%E7%94%A8%E7%8B%80%E6%85%8B%E8%A8%AD%E8%A8%88-swiftui-%E7%95%AB%E9%9D%A2-%E8%AA%8D%E8%AD%98-state-property-binding-27fea6885ead)

[Mutating Readonly Structs](https://learn.microsoft.com/en-us/archive/blogs/ericlippert/mutating-readonly-structs)

![](../assets/16911994290631.jpg)


![](../assets/16911994377956.jpg)


[Swift: Mutating Function](https://youtu.be/lXp3MNT_EZc)

[https://youtu.be/lXp3MNT_EZc](https://youtu.be/lXp3MNT_EZc)

## 4ã€Swift çš„ Copy-on-Write æ˜¯æ€ä¹ˆå®ç°çš„

1ã€Swift åˆ† å¼•â½¤ç±»å‹ (Class) å’Œå€¼ç±»å‹ (Struct / Enum)ï¼Œå€¼ç±»å‹èµ‹å€¼ã€å‡½æ•°ä¼ å€¼æ—¶ï¼Œä¼šè§¦å‘ Copy æ“ä½œï¼Œæ­¤æ—¶å¯¹å€¼ç±»å‹å†™
æ—¶å¤åˆ¶å°±èƒ½æå‡æ€§èƒ½ï¼›
ä¼˜åŠ¿ï¼š
1ï¼‰è¯»å¤šå†™å°‘çš„æƒ…å†µï¼Œå¯ä»¥æâ¾¼è¯»å–æ•ˆç‡ï¼›
2ï¼‰é›†åˆä¼ å€¼ä¹‹åä¿®æ”¹ï¼Œä¸ä¼šæ”¹å˜åŸæ¥çš„å€¼ï¼›ï¼ˆOC éœ€è¦â½¤ deep Copyï¼‰
åŠ£åŠ¿ï¼š
1ï¼‰çº¿ç¨‹ä¸å®‰å…¨ï¼Œå†™æ—¶å å†…å­˜
2ï¼‰â¾ƒå®šä¹‰çš„ç»“æ„ä½“å¹¶ä¸èƒ½â¾ƒåŠ¨æ‹¥æœ‰ å†™æ—¶å¤åˆ¶ çš„å±æ€§
Tipsï¼š
1ï¼‰å¼•â½¤ç±»å‹ä¸â½¤ Copy-on-WriteÂ  ï¼Œæ˜¯å› ä¸ºæ€§èƒ½æ¶ˆè€—â½ç›´æ¥å¤åˆ¶è¿˜â¾¼
2ï¼‰isKnownUniquelyReferenced å¯ä»¥â½¤æ¥åˆ¤æ–­ Class æ˜¯å¦è¢«å”¯â¼€å¼•â½¤ï¼Œä»â½½è¿›â¾ copy on writeï¼›
3ï¼‰Arrayã€Dictionaryã€Set ç­‰ç±»å‹éƒ½æ˜¯ Struct å®ç°çš„ï¼Œå€¼ç±»å‹ï¼Œâ½€æŒ Copy-on-Writeï¼›
å†™æ—¶å¤åˆ¶ï¼Œswift çš„æ•°ç»„ã€å­—å…¸ç­‰å°±æ˜¯å¦‚æ­¤ï¼ŒåŸæ¥æ˜¯å€¼ç±»å‹ï¼Œä½†æ˜¯é‡åˆ°å†™æ“ä½œçš„æ—¶å€™ï¼Œå¤åˆ¶â¼€ä»½å‡ºæ¥ï¼›
isKnownUniquelyReferenced æºä»£ç  ã€‚

[](https://github.com/apple/swift/blob/ad0a5bf12b9f261263f20598bc4767494ff5d678/stdlib/public/core/ManagedBuffer.swift)

è°ƒâ½¤äº†Â  Builtin.swiftÂ  

[](https://github.com/apple/swift/blob/32811bac9fa18ffea4ba79c8618216f9e71dc1d0/stdlib/public/core/Builtin.swift)

â¾¥â¾¯çš„ isUnique â½…æ³•ï¼š

å…³äº Builtinï¼šSwift Builtin

SILGen/SILGenBuiltin.cpp 

[](https://github.com/apple/swift/blob/74d7eacfe5afadb44b520f01211d00c6490a701f/lib/SILGen/SILGenBuiltin.cpp#L954)

â¾¥â¾¯çš„å®ç°ï¼šï¼ˆSIL çš„ç‰¹ç‚¹å…¶â¼†ï¼šæ£€æµ‹ä¸å¯è¾¾ï¼ˆæœªä½¿â½¤ï¼‰çš„ä»£ç  & åœ¨ä»£ç å‘é€ç»™Â LLVMÂ å‰è¿›â¾
ä¼˜åŒ–ï¼‰



```swift
"// This should only accept as an operand type single-refcounted-pointer types,
"// class existentials, or single-payload enums (optional). Type checking must be
"// deferred until IRGen so Builtin.isUnique can be called from a transparent
"// generic wrapper (we can only type check after specialization).
static ManagedValue emitBuiltinIsUnique(SILGenFunction &SGF,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  SILLocation loc,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  SubstitutionMap subs,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ArrayRef<ManagedValue> args,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  SGFContext C) {

Â  assert(subs.getReplacementTypes().size() "== 1 "&&
Â  Â  Â  Â Â  "isUnique should have a single substitution");
Â  assert(args.size() "== 1 "&& "isUnique should have a single argument");
Â  assert((args[0].getType().isAddress() "&& !args[0].hasCleanup()) "&&
Â  Â  Â  Â Â  "Builtin.isUnique takes an address.");

Â  return ManagedValue"::forUnmanaged(
Â  Â  SGF.B.createIsUnique(loc, args[0].getValue()));
}
```

swift
createIsUnique 

[](https://github.com/apple/swift/blob/74d7eacfe5afadb44b520f01211d00c6490a701f/include/swift/SIL/SILBuilder.h#L2194)

æ˜¯â¼€ä¸ª C++ â½…æ³•ï¼Œåº”è¯¥åœ¨ç¼–è¯‘æœŸå°±ç¡®å®šäº†ï¼ˆé™æ€â½…æ³•ï¼‰

ä¸‹â¾¯æ˜¯â¼€ä¸ªâ¾ƒâ¼°å®ç°  Copy-on-Write çš„ä¾‹â¼¦

```swift
"// isKnownUniquelyReferenced çš„ä½¿â½¤
isKnownUniquelyReferenced(&object: T)

final class Box<A> {
Â  Â  var unbox:A
Â  Â  init(_ value:A) {
Â  Â  Â  Â  self.unbox = value
Â  Â  }
}Â  Â 
var a = Box(NSMutableData())
isKnownUniquelyReferenced(&a)"//true
var b = aÂ 
isKnownUniquelyReferenced(&a)"//false

"// å†™æ—¶å¤åˆ¶çš„ä»£ç åŸç†
final class Ref<T> {
Â  var val : T
Â  init(_ v : T) {val = v}
}

struct Box<T> {
Â  Â  var ref : Ref<T>
Â  Â  init(_ x : T) { ref = Ref(x) }

Â  Â  var value: T {
Â  Â  Â  Â  get { return ref.val }
Â  Â  Â  Â  set {
Â  Â  Â  Â  Â  if (!isUniquelyReferencedNonObjC(&ref)) {
Â  Â  Â  Â  Â  Â  ref = Ref(newValue)
Â  Â  Â  Â  Â  Â  return
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  ref.val = newValue
Â  Â  Â  Â  }
Â  Â  }
}
```

å½“è¿›â¾ set çš„æ—¶å€™åˆ¤æ–­æ˜¯å¦æœ‰å¤šä¸ª referenceï¼Œå¦‚æœæ˜¯å¤šä¸ª reference åˆ™è¿›â¾æ‹·â»‰ï¼Œåä¹‹åˆ™ä¸ä¼šã€‚

## Swift Copy-on-Write æ˜¯æ€ä¹ˆå»å®ç°çš„?

[Understanding Copy on Write](https://fabernovel.github.io/2020-10-30/Understanding-Copy-on-Write)

åŸç†å’Œ KVOæœ‰ç‚¹ç±»ä¼¼.

```swift
// Actual CoW implementation
struct CoWSomeClass {
    init(value: Int) {
        storage = SomeClass(value: value)
    }

    private storage: SomeClass

    var value: Int {
        get {
            storage.value
        }
        set {
            if !isKnownUniquelyReferenced(&storage) {
                storage = storage.copy()
            }
            storage.value = newValue
        }
    }
}

// Storage definition
extension CoWSomeClass {
    private class SomeClass {
        var value: Int

        init(value: Int) {
            self.value = value
        }

        func copy() -> SomeClass {
            SomeClass(value: value)
        }
    }
}
```

---

### **35. What are the basic categories of types in Swift?**

Swift requires each object to have a type, which must be known during compilation. Swift types fall into two groups:

- **Value types**, which are typically described as a struct, enum, or tuple and allow each instance to maintain a separate copy of its data.
- **Reference types**, where a single copy of the data is shared by all instances, and where the type is often expressed as a class.

### **26. What is a Tuple in Swift?**

A tuple is a collection of many values combined into a single compound value. It contains elements in an organized list. You can access a tuple's object data in two ways: by name or position.

A Swift tuple can accommodate two values, one of the string and one of the integer types.

### **38. Is it possible to return multiple values from a function in Swift? If yes, how?**

Like the majority of programming languages, Swift only allows each function to return a single value. If this element is a primitive type, you will only return one value.

Additionally, a thing could be a complex type, such as a class, struct, tuple, or array. You can pack several values into a complex type in this situation. After that, you formally return a single item with numerous values kept inside this data structure.

**Hereâ€™s how we can return multiple values kept inside a tuple:**

```
func functionWithMultipleReturnValues(
val1: Int,
val2: Int
) -> (sum: Int, product: Int) {
let sum = val1 + val2
let prod = val1 * val2
return (sum, prod)
}
let result = functionWithMultipleReturnValues(val1: 10, val2: 20)
let s = result.sum
let p = result.product
```

## ï¬nal æ˜¯ä»€ä¹ˆï¼š

ä¸èƒ½ç»§æ‰¿å’Œé‡å†™,å¯â½¤åˆ° å±æ€§/å‡½æ•°/ç±»ï¼›

## String ä¸ NSString çš„å…³ç³»ä¸åŒºåˆ«ï¼š

èƒ½å¤Ÿäº’ç›¸è½¬æ¢ï¼Œâ¼€ä¸ªå€¼ç±»å‹ï¼Œâ¼€ä¸ªå¼•â½¤ç±»å‹ï¼›

## defer ä½¿â½¤åœºæ™¯ï¼š

defer â¾¥çš„å†…å®¹ä¼šåœ¨ { } ç»“æŸæ—¶æ‰§â¾ï¼›

## struct åœ¨å †åŒºè¿˜æ˜¯æ ˆåŒºï¼Ÿ

å€¼å¼•â½¤ï¼Œæ ˆåŒº

## å±æ€§ä¸­ï¼Œå€¼å±æ€§ï¼Œå’Œè®¡ç®—å±æ€§æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

è®¡ç®—å±æ€§ä¸å å†…å­˜ï¼Œå€¼å±æ€§å â½¤å†…å­˜ï¼›

## å£°æ˜â¼€ä¸ªåªæœ‰â¼€ä¸ªå‚æ•°æ²¡æœ‰è¿”å›å€¼é—­åŒ…çš„åˆ«å

```swift
typealias SomeClosuerType = (String) "-> ()
let someClosuer: SomeClosuerType = { (name: String) in
    print("hello,", name)
}
```

#### 2. Principle of Dictionary
![5](assets/5-1.jpg)

https://medium.com/swift-algorithms-extras/understanding-hash-tables-dictionaries-sets-with-swift-4605e905973e

https://chat.openai.com/share/c7881993-fedb-4089-bf83-bf8e05f1cab4


## **æ³›å‹ï¼š**

## Q.ä»€ä¹ˆæ˜¯æ³›å‹ï¼Œswiftå“ªäº›åœ°æ–¹ä½¿ç”¨äº†æ³›å‹ï¼Ÿ

ç­”ï¼š
æ³›å‹ï¼ˆgenericï¼‰å¯ä»¥ä½¿æˆ‘ä»¬åœ¨ç¨‹åºä»£ç ä¸­å®šä¹‰ä¸€äº›å¯å˜çš„éƒ¨åˆ†ï¼Œåœ¨è¿è¡Œ runtime çš„æ—¶å€™æŒ‡å®šã€‚ä½¿ç”¨æ³›å‹å¯ä»¥æœ€å¤§é™åº¦åœ°é‡ç”¨ä»£ç ã€ä¿æŠ¤ç±»å‹çš„å®‰å…¨ä»¥åŠæé«˜æ€§èƒ½ã€‚
æ³›å‹å¯ä»¥å°†ç±»å‹å‚æ•°åŒ–ï¼Œæé«˜ä»£ç å¤ç”¨ç‡ï¼Œå‡å°‘ä»£ç é‡ã€‚

ä¾‹å¦‚ optional ä¸­çš„ mapã€flatMap ã€?? (æ³›å‹åŠ é€ƒé€¸é—­åŒ…çš„æ–¹å¼ï¼Œåšä¸‰ç›®è¿ç®—)

## 

## Generic in Swift ****æ³›å‹<T>****

[An in depth look at generics in Swift â€” The Mobile Entity](https://www.themobileentity.com/home/an-in-depth-look-at-generics-in-swift)

[Swift èŒƒå‹ï¼ˆGenericsè¯‘æ–‡ï¼‰ - æ˜é‡‘](https://juejin.cn/post/6870424765958455303)

[Swift åˆä½“éªŒï¼ˆ10ï¼‰- æ³›å‹ ã€å®Œç»“ğŸ‰ğŸ‰ğŸ‰ã€‘](https://www.freecodecamp.org/chinese/news/swift-getting-started-10/)

![](../assets/16911994768336.jpg)

![](../assets/16911994872119.jpg)



![](../assets/16911994941254.jpg)


[https://chat.openai.com/share/faa41aed-9f00-4070-b6f1-ab3be7dbb238](https://chat.openai.com/share/faa41aed-9f00-4070-b6f1-ab3be7dbb238)

## 

## *10ã€æ³›å‹çš„æœ¬è´¨*

*1ï¼‰æ³›å‹çš„æœ¬è´¨æ˜¯ å‚æ•°åŒ–ç±»å‹ ï¼Œ<T> â¾¥â¾¯çš„ T å°±æ˜¯ä¸ªå ä½ç¬¦ï¼Œç³»ç»Ÿè¿™æ ·å°±ä¸ä¼šæ£€æŸ¥ç±»å‹äº†ï¼›
2ï¼‰æ³›å‹å¯ä»¥è®©å¼€å‘è€…çµæ´»å®šä¹‰å‡½æ•°å’Œç±»å‹ï¼Œé¿å…é‡å¤ä»£ç ï¼Œä½¿ä»£ç çš„è¡¨æ„æ›´æ¸…æ™°å’ŒæŠ½è±¡ï¼›
3ï¼‰associatedtypeï¼ˆå…³è”ç±»å‹ï¼‰ æ˜¯åœ¨ protocol â¾¥ä½¿â½¤çš„æ³›å‹
4ï¼‰where å­—å¥å¯ä»¥é™å®š å…³è”ç±»å‹ï¼ˆassociatedtype Element // å…³è”ç±»å‹ï¼‰çš„å…·ä½“ç±»å‹, å¦‚: extension ListProtcol where
Element = Int
5ï¼‰T å’Œ Any çš„åŒºåˆ«ï¼Ÿ
Any ç±»å‹ä¼šé¿å¼€ç±»å‹çš„æ£€æŸ¥ï¼Œå…·ä½“â»…ä¸‹â¾¯ä»£ç ä¾‹â¼¦ï¼š*

```swift

*1"//è¾“â¼Šè¾“å‡ºç±»å‹â¼€è‡´
2func add<T>( input: T) "-> T {
3Â  Â  "//""...
4Â  Â  return input;
5}
6
7"//è¾“â¼Šè¾“å‡ºç±»å‹ä¼šä¸â¼€è‡´
8func anyAdd(* input: Any) "-> Any {
9Â  Â  "//""...
10Â  Â  return input;
11}

```


#### 7. What's the difference between `opaque type` and `generic`?
https://docs.swift.org/swift-book/documentation/the-swift-programming-language/opaquetypes/

https://chat.openai.com/share/87bd8875-d80d-4567-97f6-fe869edc8f7b

![4](assets/4-1.jpg)



![7](assets/7-1.jpg)
![2](assets/2-2.jpg)
![3](assets/3-2.jpg)
![4](assets/4-2.jpg)
![5](assets/5-2.jpg)
![6](assets/6-1.jpg)



ç±»å‹å®šä¹‰æ–¹å¼ | å®šä¹‰|ä¼˜ç‚¹|ç¼ºç‚¹ | å…¸å‹åœºæ™¯
:-------------:|:-------------:|:-------------:|:-------------:|:-------------:
Opaque Type| ä¿ç•™ç±»å‹ä¿¡æ¯ï¼Œä½†éšè—å…·ä½“ç±»å‹ã€‚Opaque Typeåœ¨è¿”å›æ—¶ä¿ç•™ç±»å‹ä¿¡æ¯ã€‚æœ‰åŠ©äºä»£ç é‡ç”¨å’Œçµæ´»æ€§ã€‚| ä¿ç•™ç±»å‹ä¿¡æ¯ã€‚ </p>æä¾›äº†æ›´æ˜ç¡®çš„è¿”å›ç±»å‹çš„çº¦æŸã€‚</p>éšè—å®ç°ç»†èŠ‚ã€‚| åœ¨ç±»å‹æ¨æ–­å’Œç¼–è¯‘æ—¶é—´ä¸Šå¯èƒ½æœ‰ä¸€äº›å¼€é”€ã€‚ </p>æ— æ³•ç›´æ¥æŸ¥çœ‹å’Œæ“ä½œå†…éƒ¨ç±»å‹ã€‚</p>å¯èƒ½ä¸å¦‚æ³›å‹é‚£æ ·çµæ´»ã€‚| SwiftUIä¸­çš„some Viewã€‚</p> ```var body: some View { Text("Hello, World!") }```
ç±»å‹æ“¦é™¤ | éšè—å…·ä½“ç±»å‹ï¼Œä½†éµå¾ªç‰¹å®šåè®®ã€‚ | éšè—å…·ä½“ç±»å‹ï¼Œå®ç°äº†å°è£…ã€‚</p>å…è®¸æˆ‘ä»¬ä½¿ç”¨ç‰¹å®šåè®®ç±»å‹ï¼Œè€Œä¸ç”¨å…³å¿ƒå…·ä½“å®ç°ã€‚| åœ¨æ“¦é™¤ç±»å‹åï¼ŒåŸå§‹ç±»å‹ä¿¡æ¯æ— æ³•æ¢å¤ï¼Œå¯èƒ½ä¼šä¸§å¤±ä¸€äº›åŠŸèƒ½ã€‚</p>åˆ›å»ºç±»å‹æ“¦é™¤å®¹å™¨å¯èƒ½ä¼šå¢åŠ ä»£ç å¤æ‚æ€§ã€‚</p>åœ¨æ€§èƒ½ä¸Šå¯èƒ½æœ‰ä¸€äº›å¼€é”€ã€‚| Swiftçš„AnyPublisherï¼Œå®ƒå¯ä»¥æŒæœ‰ä»»ä½•å®ç°äº†Publisheråè®®çš„ç±»å‹ã€‚</p>```func fetchData() -> AnyPublisher<Data, Error> {URLSession.shared.dataTaskPublisher(for: url).map(\.data).eraseToAnyPublisher()}```
Generic | å…è®¸ä½ ç¼–å†™çµæ´»å¯é‡ç”¨çš„å‡½æ•°å’Œç±»å‹ï¼Œå¯é€‚åº”ä»»ä½•ç±»å‹ã€‚ |  å¼ºç±»å‹ï¼Œæä¾›äº†ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨æ€§ã€‚ </p>å…è®¸ç¼–å†™çµæ´»çš„ã€å¯é‡ç”¨çš„ä»£ç ã€‚|  ç”¨èµ·æ¥å¯èƒ½æ¯”è¾ƒå¤æ‚ï¼Œå°¤å…¶æ˜¯å¯¹äºå¤æ‚çš„æ³›å‹ä»£ç ï¼Œå¾ˆéš¾ç†è§£å’Œè°ƒè¯•ã€‚</p>å¯èƒ½ä¼šå¢åŠ ç¼–è¯‘æ—¶é—´ã€‚</p>æ— æ³•ç”¨äºæŸäº›åŠ¨æ€çš„åœºæ™¯ï¼Œå¦‚éœ€è¦åœ¨è¿è¡Œæ—¶æ”¹å˜ç±»å‹ã€‚| å®¹å™¨ç±»å¦‚Arrayå’ŒDictionary,</p> ```func swapTwoValues<T>(_ a: inout T, _ b: inout T) { let temporaryA = a;a = b;b = temporaryA}```
Any? | å¯ä»¥å­˜å‚¨ä»»ä½•ç±»å‹çš„å€¼ï¼ŒåŒ…æ‹¬å¯é€‰å€¼ã€‚| å®Œå…¨çµæ´»ï¼Œå¯ä»¥ä»£è¡¨ä»»ä½•ç±»å‹ã€‚| ç¼ºä¹ç±»å‹å®‰å…¨ã€‚ä½ éœ€è¦è‡ªè¡Œç¡®å®šç±»å‹ï¼Œå¹¶åšæ­£ç¡®çš„ç±»å‹è½¬æ¢ã€‚å¦‚æœä¸æ­£ç¡®ï¼Œå¯èƒ½ä¼šåœ¨è¿è¡Œæ—¶å‡ºé”™ã€‚</p> å®¹æ˜“å¯¼è‡´ä»£ç æ··ä¹±ï¼Œéš¾ä»¥è¿½è¸ªå’Œè°ƒè¯•ã€‚</p>å¯¹äºå¼€å‘è€…æ¥è¯´ï¼Œæ— æ³•ç¡®å®šå…·ä½“çš„ç±»å‹ï¼Œå¾ˆéš¾åšå‡ºæ­£ç¡®çš„æ“ä½œã€‚| è§£æJSON, </p> ```let value: Any? = "Hello, World!"; if let string = value as? String {    print("It's a string: \(string)"); } else if let number = value as? Int {    print("It's an integer: \(number)"); }```


ä»  Protocolsä¸­ å®šä¹‰æ–¹(å¼€å‘è€…) å’Œ è°ƒç”¨æ–¹(ä½¿ç”¨è€…)çš„è§’åº¦æ¥è¯´.
- Genericsä¸­ï¼Œæ˜¯å¼€å‘è€…ä¸éœ€è¦çŸ¥é“ç±»å‹æˆ–åè®®ï¼Œä½†æ˜¯ä½¿ç”¨è€…çŸ¥é“ç±»å‹æˆ–åè®®ã€‚
- Opaqueä¸­ï¼Œæ˜¯å¼€å‘è€…çŸ¥é“åè®®ï¼Œä½†æ˜¯ä½¿ç”¨è€…ä¸çŸ¥é“åè®®ã€‚
- Type Erasureæ˜¯åœ¨Genericsçš„åŸºç¡€ä¹‹ä¸Š,é€šè¿‡ç›’å­åŒ…è£…æ¥è§„é¿ç¼–è¯‘å™¨çš„ä¸€ç§æ–¹å¼ã€‚


ä¸åŒç±»å‹ | å¯¹æ¯”
:-------------:|:-------------:
Opaque Type ä¸ Generic | Opaque Typeå’Œæ³›å‹éƒ½æœ‰åŠ©äºä»£ç é‡ç”¨å’Œçµæ´»æ€§ã€‚æ³›å‹åœ¨å®šä¹‰æ—¶ä¸çŸ¥é“å…·ä½“ç±»å‹ï¼Œè€ŒOpaque Typeåœ¨è¿”å›æ—¶ä¿ç•™ç±»å‹ä¿¡æ¯ã€‚
Opaque Type ä¸ Any? | Opaque Typeéšè—å…·ä½“ç±»å‹ä½†ä¿ç•™ç±»å‹ä¿¡æ¯ï¼›Any?ä¸ä¿ç•™ç±»å‹ä¿¡æ¯ã€‚
ç±»å‹æ“¦é™¤ä¸ Generic |  ç±»å‹æ“¦é™¤é€šå¸¸ç”¨äºç‰¹å®šåè®®ï¼Œéšè—å…·ä½“ç±»å‹ï¼›æ³›å‹æä¾›æ›´å¹¿æ³›çš„çµæ´»æ€§ï¼Œå…è®¸ä»»ä½•ç±»å‹ã€‚
ç±»å‹æ“¦é™¤ä¸ Any? | ç±»å‹æ“¦é™¤éµå¾ªåè®®ï¼Œæœ‰ç»“æ„ï¼›Any?å®Œå…¨çµæ´»ï¼Œå…è®¸ä»»ä½•ç±»å‹ã€‚
Generic ä¸ Any?|  æ³›å‹å¼ºåˆ¶æ‰§è¡Œç±»å‹ä¸€è‡´æ€§ï¼Œæä¾›ç±»å‹å®‰å…¨ï¼›Any?å®Œå…¨çµæ´»ä½†ç¼ºä¹ç±»å‹å®‰å…¨ã€‚


ä¸¾ä¾‹è¯´æ˜, ä¸¾ä¸€ä¸ªMVVMæ¶æ„çš„ä¾‹å­ï¼Œå°†Modelä¸­çš„æŸäº›å…·ä½“ç±»å‹ç”¨Opaque Typesè¡¨è¾¾ï¼Œç„¶åå†è¿›è¡Œæ”¹é€ ã€‚

å…ˆä¸¾ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ª"User"çš„æ¨¡å‹ï¼Œå…·ä½“ç±»å‹ç”¨Opaque Typesè¡¨è¾¾ï¼Œå¹¶åˆ›å»ºä¸€ä¸ª"UserViewModel"æ¥å¤„ç†è¯¥æ¨¡å‹ã€‚

### Any?
![](assets/16912874108037.jpg)

æˆ‘ä»¬å¯ä»¥æŠŠidç±»å‹è®¾ç½®ä¸ºAny?ï¼Œä½¿å¾—æˆ‘ä»¬å¯ä»¥æ¥å—ä»»ä½•ç±»å‹çš„idã€‚

```swift
protocol Model {
    var id: Any? { get }
}

struct User: Model {
    var id: Any?
}

protocol ViewModel {
    associatedtype ModelType: Model
    init(model: ModelType)
}

struct UserViewModel: ViewModel {
    var model: User

    init(model: User) {
        self.model = model
    }
}
```


### æ³›å‹
![](assets/16912874480991.jpg)

é€šè¿‡ä½¿ç”¨æ³›å‹ï¼Œæˆ‘ä»¬å¯ä»¥ä¿æŒç±»å‹çš„å®‰å…¨æ€§ï¼Œè€Œä¸å¿…çŸ¥é“å…·ä½“ç±»å‹ã€‚

```swift
protocol Model {
    associatedtype Identifier
    var id: Identifier { get }
}

struct User: Model {
    typealias Identifier = UUID
    var id: Identifier
}

protocol ViewModel {
    associatedtype ModelType: Model
    init(model: ModelType)
}

struct UserViewModel<M: Model>: ViewModel {
    var model: M

    init(model: M) {
        self.model = model
    }
}
```
è¿™æ ·ï¼ŒUserViewModelå¯ä»¥å¤„ç†ä»»ä½•æ»¡è¶³Modelåè®®çš„ç±»å‹ã€‚

### ç±»å‹æ“¦é™¤

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç±»å‹æ“¦é™¤æ¥éšè—å…·ä½“ç±»å‹ï¼Œé€šå¸¸ä½¿ç”¨ä¸€ç§åŒ…è£…å™¨æ¥å®ç°ã€‚å¦‚ä¸‹é¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªAnyModelæ¥éšè—å…·ä½“çš„Modelç±»å‹ï¼š
![](assets/16912874813432.jpg)

```swift
protocol Model {
    associatedtype Identifier
    var id: Identifier { get }
}

struct User: Model {
    typealias Identifier = UUID
    var id: Identifier
}

struct AnyModel: Model {
    typealias Identifier = Any
    
    var id: Identifier
    
    init<M: Model>(_ model: M) {
        self.id = model.id as! Identifier
    }
}

protocol ViewModel {
    associatedtype ModelType: Model
    init(model: ModelType)
}

struct UserViewModel: ViewModel {
    var model: AnyModel

    init(model: User) {
        self.model = AnyModel(model)
    }
}
```
è¿™æ ·ï¼Œå…·ä½“çš„Modelç±»å‹è¢«éšè—åœ¨äº†AnyModelé‡Œé¢ï¼ŒUserViewModelåªçŸ¥é“å®ƒå¤„ç†çš„æ˜¯ä¸€ä¸ªæ»¡è¶³Modelåè®®çš„å¯¹è±¡ã€‚



### Opaque Types
Opaque Typesåœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æ— éœ€å…¬å¼€å…·ä½“çš„Modelç±»å‹ï¼Œåªéœ€è¡¨è¾¾å®ƒéµå¾ªäº†æŸä¸ªåè®®ã€‚
![](assets/16912875027729.jpg)

```swift
protocol Model {
    associatedtype Identifier
    var id: Identifier { get }
}

struct User: Model {
    typealias Identifier = UUID
    var id: Identifier
}

protocol ViewModel {
    associatedtype ModelType: Model
    init(model: ModelType)
}

struct UserViewModel: ViewModel {
    var model: some Model

    init(model: User) {
        self.model = model
    }
}
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼ŒViewModelä¸çŸ¥é“å…·ä½“çš„Modelç±»å‹ï¼ŒåªçŸ¥é“Modelæ»¡è¶³æŸä¸ªåè®®ï¼Œä»è€Œå®ç°äº†å°è£…ã€‚

æ‰€æœ‰èƒ½ç”¨Genericçš„åœºæ™¯éƒ½å¯ä»¥ä½¿ç”¨Opaque Type å—? æˆ‘æ˜¯å¦åº”è¯¥æŠŠæ‰€æœ‰çš„Genericçš„å‡çº§åˆ°ä½¿ç”¨Opaque Type?

ä¸¾ä¸€ä¸ªå¯ä»¥ç”¨Genericçš„åœºæ™¯, ä½†æ˜¯å´ä¸å¯ä»¥ä½¿ç”¨Opaque Type çš„ä¾‹å­. 
ä¸€ä¸ªå…¸å‹çš„åœºæ™¯å°±æ˜¯æ³›å‹å®¹å™¨ï¼Œæ¯”å¦‚ä¸€ä¸ªå¯ä»¥å‚¨å­˜ä»»ä½•ç±»å‹çš„æ•°ç»„ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ç±»å‹å£°æ˜å’Œå®ä¾‹åŒ–æ—¶éƒ½ä½¿ç”¨åŒä¸€ä¸ªç±»å‹å‚æ•°ï¼Œå› æ­¤æˆ‘ä»¬ä¸èƒ½ä½¿ç”¨Opaque Typeã€‚è¯·çœ‹ä»¥ä¸‹çš„ä¾‹å­ï¼š

```swift
struct GenericArray<Element> {
    var elements: [Element]
    
    init(_ elements: [Element]) {
        self.elements = elements
    }
    
    func getElement(at index: Int) -> Element {
        return elements[index]
    }
}

let intArray = GenericArray([1, 2, 3])
let firstElement = intArray.getElement(at: 0) // Returns 1

let stringArray = GenericArray(["Hello", "World"])
let firstString = stringArray.getElement(at: 0) // Returns "Hello"
```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªåä¸º`GenericArray`çš„æ³›å‹ç»“æ„ä½“ï¼Œå®ƒå¯ä»¥å‚¨å­˜ä»»ä½•ç±»å‹çš„æ•°ç»„ã€‚æˆ‘ä»¬å¯ä»¥åœ¨å®ä¾‹åŒ–`GenericArray`æ—¶æŒ‡å®š`Element`çš„å…·ä½“ç±»å‹ï¼ˆä¾‹å¦‚`Int`æˆ–`String`ï¼‰ï¼Œç„¶ååœ¨è°ƒç”¨`getElement(at:)`æ–¹æ³•æ—¶ï¼Œè¿”å›å€¼çš„ç±»å‹ä¹Ÿä¼šæ˜¯æˆ‘ä»¬æŒ‡å®šçš„ç±»å‹ã€‚

ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬å°è¯•ä½¿ç”¨Opaque Typeæ¥æ›¿æ¢è¿™ä¸ªä¾‹å­ä¸­çš„æ³›å‹ï¼Œæˆ‘ä»¬ä¼šé‡åˆ°é—®é¢˜ã€‚Opaque Typeåªèƒ½ç”¨åœ¨å‡½æ•°æˆ–æ–¹æ³•çš„è¿”å›ç±»å‹ä¸Šï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•ä½¿ç”¨å®ƒæ¥å®šä¹‰ä¸€ä¸ªå¯ä»¥å‚¨å­˜ä»»æ„ç±»å‹çš„æ•°ç»„ã€‚å³ä½¿æˆ‘ä»¬å¯ä»¥åœ¨å‡½æ•°æˆ–æ–¹æ³•çš„è¿”å›å€¼ä¸­ä½¿ç”¨Opaque Typeï¼Œä¹Ÿæ— æ³•åœ¨å…¶ä»–åœ°æ–¹ä½¿ç”¨ç›¸åŒçš„ç±»å‹ï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•å®ç°å’Œä¸Šé¢ä¾‹å­ä¸­ä¸€æ ·çš„åŠŸèƒ½ã€‚




å„ç§æ–¹æ³•éƒ½æœ‰å…¶ä¼˜ç‚¹å’Œç¼ºç‚¹ã€‚Opaque Typesä¿æŒç±»å‹ä¸€è‡´æ€§ï¼Œä½†ä¸èƒ½ç”¨äºå­˜å‚¨å˜é‡ã€‚ç±»å‹æ“¦é™¤éšè—äº†å…·ä½“ç±»å‹ï¼Œä½†å¯èƒ½ä½¿æ€§èƒ½ä¸‹é™ã€‚æ³›å‹æä¾›äº†ç±»å‹å®‰å…¨ï¼Œä½†å¯èƒ½ä¼šä½¿ä»£ç å˜å¾—å¤æ‚ã€‚Any?æ˜¯æœ€çµæ´»çš„ï¼Œä½†æ˜¯åœ¨ä½¿ç”¨æ—¶éœ€è¦è¿›è¡Œç±»å‹æ£€æŸ¥æˆ–å¼ºåˆ¶ç±»å‹è½¬æ¢ã€‚



## å†…å­˜ç®¡ç†ã€**æ€§èƒ½ä¼˜åŒ–å’Œè°ƒè¯•ï¼š**

## When do you use static variables?

[https://chat.openai.com/share/3ce697b3-5f00-41b9-be78-693a4bc9a8b0](https://chat.openai.com/share/3ce697b3-5f00-41b9-be78-693a4bc9a8b0)

static å…³é”®å­—å’Œ class å…³é”®å­— ä¿®é¥°çš„ç±»â½…æ³•æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ
static ä¿®é¥°çš„ä¸èƒ½è¢«ç»§æ‰¿ï¼Œclass ä¿®é¥° å¯ä»¥è¢«ç»§æ‰¿ï¼›
class åªèƒ½åœ¨ç±»â¾¥â½¤ï¼Œä¸èƒ½åœ¨ç»“æ„ä½“ã€æšä¸¾ä¸­â½¤ï¼›
class åªèƒ½ä¿®é¥°è®¡ç®—å±æ€§ï¼Œä¸èƒ½ä¿®é¥°å€¼å±æ€§ï¼›

## What is weak and unowned in Swift? What is their difference?

https://www.advancedswift.com/strong-weak-unowned-in-swift/

iOS weak å’Œ unowned åŒºåˆ«? 

swift weak å’Œ unowned çš„åŒºåˆ«

weak åŒ OC ï¼Œåœ¨æ²¡æœ‰å¼•â½¤æŠ€æœ¯çš„æ—¶å€™â¾ƒåŠ¨ç½®ç©ºï¼Œå¿…é¡»è¢«â½£å‘½ä¸º varï¼›
unowned ä¸ä¼šä¸ºç©ºï¼Œå¯ä»¥ä½¿â½¤ let å£°æ˜ï¼Œæ€§èƒ½æŸè€—â½ weak â¼©â¼€ç‚¹ï¼Œ
è¦ä¿è¯ unowned çš„â½£å‘½å‘¨æœŸè¦å’Œå¼ºå¼•â½¤å¯¹è±¡åŒæ ·æˆ–è€…æ›´â»“ï¼Œä¸ç„¶å°±ä¼šå¯¼è‡´å´©æºƒï¼›

## è§£å†³ retain cycle, ä»€ä¹ˆæ—¶å€™ç”¨unownedã€weakã€closure capture list??
![1](assets/1-2.jpg)

In Swift, both `weak` and `unowned` are ways to prevent strong reference cycles (also known as retain cycles) which can cause memory leaks in your application. When two instances of classes reference each other, and they both have strong references to each other, they can't be deallocated because each thinks that the other is still in use. This is where `weak` and `unowned` come into play.

`weak` and `unowned` references allow one instance in a reference cycle to refer to the other instance without keeping a strong hold on it, helping to prevent strong reference cycles.

**Weak**

A `weak` reference is a reference that doesn't keep the referenced object alive. The weak reference becomes `nil` as soon as the referenced object is deallocated. Because weak references can become `nil`, they must be declared as optional types.

Here is an example of `weak`:

```
class MyClass {
    weak var weakProperty: AnotherClass?
}

```

In this case, `weakProperty` is a weak reference. If the `AnotherClass` instance it references is deallocated, `weakProperty` will be automatically set to `nil`.

**Unowned**

An `unowned` reference doesn't keep the referenced object alive, similar to a `weak` reference. However, unlike a weak reference, an unowned reference is assumed to always have a value; thus, it is non-optional. An unowned reference should be used when you know that the reference will always have a value and you don't want to deal with unwrapping an optional.

Here is an example of `unowned`:

```
class MyClass {
    unowned var unownedProperty: AnotherClass
}

```

In this case, `unownedProperty` is an unowned reference. If the `AnotherClass` instance it references is deallocated, `unownedProperty` will still hold a reference to the now-deallocated object, leading to a runtime error if it is accessed.

**Comparison**

The primary difference between `weak` and `unowned` references is that `weak` references are optional and can become `nil`, while `unowned` references are always expected to have a value.

Therefore, you would typically use `weak` when there's a possibility the referenced object might be deallocated while still being weakly referenced (e.g. delegates). Conversely, you would use `unowned` when you know the referenced object will stick around for as long as the object holding the reference is around (e.g. closures referencing `self` where `self` will outlive the closure).

![](../assets/16912025406113.jpg)


closure æ•è·å˜é‡çš„å‡ ç§æ–¹å¼:
"æ‡’æ•è·"ï¼ˆLazy Captureï¼‰å’Œ"æ—©æ•è·"ï¼ˆEager Captureï¼‰æ˜¯ä¸¤ç§æè¿°Swifté—­åŒ…æ•è·å˜é‡æˆ–å¸¸é‡æ–¹å¼çš„æœ¯è¯­ã€‚è¿™ä¸¤ç§æ¦‚å¿µå¹¶ä¸æ˜¯Swiftå®˜æ–¹æ–‡æ¡£ä¸­æ˜ç¡®å®šä¹‰çš„ï¼Œä½†å®ƒä»¬æœ‰åŠ©äºç†è§£é—­åŒ…å¦‚ä½•ä¸å…¶å‘¨å›´çš„ä½œç”¨åŸŸäº¤äº’ã€‚

### æ‡’æ•è·ï¼ˆLazy Captureï¼‰

"æ‡’æ•è·"é€šå¸¸æŒ‡çš„æ˜¯å½“é—­åŒ…è¢«æ‰§è¡Œæ—¶ï¼Œå®ƒæ‰ä¼šæ•è·å‘¨å›´ä½œç”¨åŸŸä¸­çš„å˜é‡ã€‚è¿™æ„å‘³ç€å¦‚æœå˜é‡åœ¨é—­åŒ…åˆ›å»ºåå’Œæ‰§è¡Œå‰å‘ç”Ÿäº†æ”¹å˜ï¼Œé—­åŒ…å°†ä½¿ç”¨æœ€æ–°çš„å€¼ã€‚

```swift
var lazyVar = 1
let lazyCapture = {
    print("Lazy Capture: \(lazyVar)")
}
lazyVar = 2
lazyCapture()  // è¾“å‡º "Lazy Capture: 2"
```

### æ—©æ•è·ï¼ˆEager Captureï¼‰

"æ—©æ•è·"åˆ™æ˜¯æŒ‡åœ¨é—­åŒ…åˆ›å»ºçš„æ—¶å€™ï¼Œå°±æ•è·äº†å‘¨å›´ä½œç”¨åŸŸä¸­çš„å˜é‡æˆ–å¸¸é‡ã€‚æœ€å¸¸è§çš„ä½¿ç”¨åœºæ™¯å°±æ˜¯é€šè¿‡æ•è·åˆ—è¡¨æ˜ç¡®æŒ‡å®šæ•è·ã€‚

```swift
var eagerVar = 1
let eagerCapture = { [eagerVar] in
    print("Eager Capture: \(eagerVar)")
}
eagerVar = 2
eagerCapture()  // è¾“å‡º "Eager Capture: 1"
```

### ç»„åˆæƒ…å†µ

å½“ç„¶ï¼Œä½ ä¹Ÿå¯ä»¥åœ¨åŒä¸€ä¸ªé—­åŒ…ä¸­ä½¿ç”¨å¤šç§æ•è·æ–¹å¼ã€‚

```swift
var var1 = 1
var var2 = 1

let mixedCapture = { [var1] in
    print("Eager Capture: \(var1)")
    print("Lazy Capture: \(var2)")
}

var1 = 2
var2 = 2
mixedCapture()  
// è¾“å‡º "Eager Capture: 1"
// è¾“å‡º "Lazy Capture: 2"
```

è¿™æ ·ï¼Œ`var1` æ˜¯åœ¨é—­åŒ…åˆ›å»ºæ—¶å°±è¢«æ•è·çš„ï¼ˆæ—©æ•è·ï¼‰ï¼Œè€Œ `var2` æ˜¯åœ¨é—­åŒ…æ‰§è¡Œæ—¶è¢«æ•è·çš„ï¼ˆæ‡’æ•è·ï¼‰ã€‚

### ä»€ä¹ˆæ˜¯ Capture List?

åœ¨Swiftä¸­ï¼Œæ•è·åˆ—è¡¨ï¼ˆCapture Listï¼‰æ˜¯å”¯ä¸€æ˜ç¡®æŒ‡å®šé—­åŒ…æ•è·å˜é‡æˆ–å¸¸é‡æ–¹å¼çš„è¯­æ³•ã€‚æ•è·åˆ—è¡¨ç”¨æ–¹æ‹¬å· `[]` åŒ…å›´ï¼Œå¹¶æ”¾åœ¨é—­åŒ…è¡¨è¾¾å¼çš„å¼€å§‹å¤„ã€‚

åœ¨æ•è·åˆ—è¡¨ä¸­ï¼Œä½ å¯ä»¥æ˜ç¡®åœ°æŒ‡å®šä»¥å€¼çš„æ–¹å¼æ•è·ï¼ˆå³æ•è·å½“å‰çŠ¶æ€ä¸‹çš„å€¼ï¼‰ï¼Œæˆ–ä»¥å¼•ç”¨çš„æ–¹å¼æ•è·ï¼ˆå³åˆ›å»ºä¸€ä¸ªæŒ‡å‘å¯¹è±¡çš„å¼ºå¼•ç”¨æˆ–å¼±å¼•ç”¨ï¼‰ã€‚

### å€¼ç±»å‹æ•è·

```swift
var x = 10
let captureValue = { [x] in
    print("captured value: \(x)")  // è¾“å‡ºï¼šcaptured value: 10
}
x = 20
captureValue()  // è¿˜æ˜¯è¾“å‡ºï¼šcaptured value: 10
```

### å¼•ç”¨ç±»å‹æ•è·

```swift
class MyClass {
    var value = 0
}

let obj = MyClass()
obj.value = 10

let captureReference = { [obj] in
    print("captured value: \(obj.value)")  // è¾“å‡ºï¼šcaptured value: 10
}

obj.value = 20
captureReference()  // è¾“å‡ºï¼šcaptured value: 20
```

### å¼±å¼•ç”¨å’Œæ— ä¸»å¼•ç”¨

ä½¿ç”¨ `weak` æˆ– `unowned` å¯ä»¥é¿å…å¼ºå¼•ç”¨å¯¼è‡´çš„å¾ªç¯å¼•ç”¨é—®é¢˜ã€‚

```swift
class MyClass {
    var value = 0
}

var obj: MyClass? = MyClass()
obj?.value = 10

let captureWeakReference = { [weak obj] in
    print("captured value: \(obj?.value ?? -1)")  // è¾“å‡ºï¼šcaptured value: 10
}

obj?.value = 20
captureWeakReference()  // è¾“å‡ºï¼šcaptured value: 20

obj = nil
captureWeakReference()  // è¾“å‡ºï¼šcaptured value: -1
```


-------

ç›¸ä¼¼ä¹‹å¤„ï¼š

1. Swift çš„ Capture List å’Œ Objective-C çš„ __block å’Œ __weak éƒ½æ˜¯ç”¨æ¥æ›´æ”¹é—­åŒ…æˆ– block å¯¹å…¶å¤–éƒ¨å˜é‡çš„æ•è·æ–¹å¼ï¼Œä»¥ä¾¿æ›´å¥½åœ°ç®¡ç†å†…å­˜å’Œæ§åˆ¶å¼•ç”¨ã€‚
2. å®ƒä»¬éƒ½å¯ä»¥é˜²æ­¢å¾ªç¯å¼•ç”¨çš„é—®é¢˜ï¼Œä»è€Œé¿å…å†…å­˜æ³„æ¼ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨æ•è·åˆ—è¡¨æ¥é¿å…å¾ªç¯å¼•ç”¨çš„ä¾‹å­ï¼š

```swift
class MyClass {
    var value = 0
    var closure: (() -> Void)?

    init() {
        closure = { [weak self] in
            guard let self = self else {
                return
            }
            print(self.value)
        }
    }

    deinit {
        print("MyClass has been deinitialized")
    }
}

do {
    let instance = MyClass()
    instance.value = 1
    instance.closure?()
} // MyClass has been deinitialized will be printed, indicating there's no retain cycle.

```

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å°†é—­åŒ…çš„å®šä¹‰æ”¾åœ¨äº†ç±»çš„åˆå§‹åŒ–æ–¹æ³•ä¸­ï¼Œå¹¶ä¸”åœ¨é—­åŒ…å†…éƒ¨ä½¿ç”¨äº† selfã€‚ä½†æ˜¯æˆ‘ä»¬ä½¿ç”¨äº† `[weak self]` åœ¨æ•è·åˆ—è¡¨ä¸­æŒ‡å®šäº† self çš„æ•è·æ–¹å¼ï¼Œæ‰€ä»¥åœ¨é—­åŒ…å†…éƒ¨ï¼Œself æ˜¯ä¸€ä¸ª Optional ç±»å‹ã€‚å½“ MyClass çš„å®ä¾‹è¢«é‡Šæ”¾æ—¶ï¼Œç”±äºæˆ‘ä»¬æ‰“ç ´äº†å¾ªç¯å¼•ç”¨ï¼Œæ‰€ä»¥ MyClass çš„ deinit æ–¹æ³•ä¼šè¢«è°ƒç”¨ï¼Œè¿™è¯æ˜æˆ‘ä»¬é¿å…äº† retain cycleã€‚

åŒºåˆ«ï¼š

1. Swift ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨é—­åŒ…å†…éƒ¨å®šä¹‰æ•è·åˆ—è¡¨æ¥æ˜¾å¼å£°æ˜æ•è·æ–¹å¼ï¼Œæ”¯æŒ unownedï¼Œweak æˆ–å€¼æ•è·ã€‚è€Œåœ¨ Objective-C ä¸­ï¼Œæˆ‘ä»¬éœ€è¦åœ¨å£°æ˜å˜é‡æ—¶ä½¿ç”¨ __block æˆ– __weakï¼Œå®ƒä»¬åªèƒ½ä½¿ç”¨è¿™ä¸¤ç§æ–¹å¼ã€‚
2. åœ¨ Swift ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æ•è·åˆ—è¡¨ä¸­æ•è·å¤šä¸ªå˜é‡ï¼Œæ¯ä¸ªå˜é‡çš„æ•è·æ–¹å¼å¯ä»¥ä¸åŒã€‚åœ¨ Objective-C ä¸­ï¼Œæˆ‘ä»¬éœ€è¦å¯¹æ¯ä¸ªéœ€è¦æ•è·çš„å˜é‡å•ç‹¬ä½¿ç”¨ __block æˆ– __weakã€‚
3. Swift çš„æ•è·åˆ—è¡¨æä¾›äº†æ›´å¤šçš„çµæ´»æ€§å’Œæ§åˆ¶åŠ›ï¼Œæ¯”å¦‚ä½ å¯ä»¥åœ¨æ•è·åˆ—è¡¨ä¸­æ•è·å˜é‡çš„å½“å‰å€¼ï¼Œå³ä½¿å®ƒåœ¨å¤–éƒ¨æ”¹å˜äº†ï¼Œé—­åŒ…å†…éƒ¨çš„å€¼ä¹Ÿä¸ä¼šæ”¹å˜ã€‚åœ¨ Objective-C ä¸­ï¼Œ__block å˜é‡ä¼šå…±äº«å€¼ï¼Œå³åœ¨ block å†…éƒ¨æˆ–å¤–éƒ¨æ”¹å˜ï¼Œä¸¤è¾¹éƒ½ä¼šçœ‹åˆ°æ–°çš„å€¼ã€‚
4. Swift çš„è¯­æ³•æ›´åŠ ç°ä»£å’Œç®€æ´ï¼Œå¯¹äºå¼•ç”¨çš„ç®¡ç†ä¹Ÿæ›´åŠ è‡ªåŠ¨åŒ–ï¼Œå‡å°‘äº†æ‰‹åŠ¨å†…å­˜ç®¡ç†çš„å¤æ‚æ€§ã€‚åœ¨ Objective-C ä¸­ï¼Œå¼€å‘è€…éœ€è¦æ›´åŠ å°å¿ƒåœ°ç®¡ç†å†…å­˜å’Œå¼•ç”¨ã€‚

## ä¸¾ä¾‹è¯´æ˜ Capture List çš„æ•è·å˜é‡åçš„ç‰¹ç‚¹

Capture List , å˜é‡æ•è·, æˆ‘ä¸¾äº†ä¸‹é¢çš„ä¸¤ä¸ªä¾‹å­, è¿™æ ·å¯¹æ¯”èµ·æ¥æ¯”è¾ƒæ¸…æ™°, èƒ½å¤Ÿçœ‹å‡ºæ¥ æ•è·å, å˜é‡å¤–éƒ¨æ”¹å˜ä¸ä¼šå¼•èµ·é—­åŒ…é‡Œæ”¹å˜çš„æ”¹å˜.

ç¬¬1ä¸ªä¾‹å­(å‘½åä¸º "valueCaptureExample"):

```swift
var capturedValue: Int = 0

func captureAndChange(_ closure: @escaping () -> ()) {
    closure()
}

print(capturedValue)  // æ‰“å°0

captureAndChange { capturedValue = 1 }

print(capturedValue)  // æ‰“å°1

```

ç¬¬2ä¸ªä¾‹å­(å‘½åä¸º "valueCaptureListExample"):

```swift
var capturedValue: Int = 0

let valueCaptureListClosure = { [capturedValue] in
    print(capturedValue)
}

capturedValue = 1

valueCaptureListClosure()  // æ‰“å°0ï¼Œè¯´æ˜é—­åŒ…çœ‹åˆ°çš„æ˜¯æ•è·æ—¶çš„ capturedValue çš„å€¼ï¼Œè€Œä¸æ˜¯å½“å‰çš„å€¼

```

ç°åœ¨ï¼Œæˆ‘ä»¬æ¥å¯¹æ¯”ç¤ºä¾‹ï¼š

- "valueCaptureExample"ï¼ˆå€¼æ•è·ç¤ºä¾‹ï¼‰: åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`capturedValue` æ˜¯ä¸€ä¸ªå€¼ç±»å‹ï¼Œå®ƒè¢«ä¸€ä¸ªæ²¡æœ‰æŒ‡å®šæ•è·åˆ—è¡¨çš„é—­åŒ…æ•è·ã€‚è¿™ä¸ªé—­åŒ…å¯ä»¥æ”¹å˜ `capturedValue` çš„å€¼ï¼Œå¹¶ä¸”è¿™ä¸ªæ”¹å˜ä¼šå½±å“åˆ°å¤–éƒ¨çš„ `capturedValue`ã€‚
- "valueCaptureListExample"ï¼ˆå€¼æ•è·åˆ—è¡¨ç¤ºä¾‹ï¼‰: åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`capturedValue` æ˜¯ä¸€ä¸ªå€¼ç±»å‹ï¼Œå®ƒè¢«ä¸€ä¸ªæŒ‡å®šäº†æ•è·åˆ—è¡¨çš„é—­åŒ…æ•è·ã€‚è¿™ä¸ªé—­åŒ…æ•è·çš„æ˜¯åˆ›å»ºé—­åŒ…æ—¶ `capturedValue` çš„å€¼ï¼Œè€Œä¸æ˜¯è¿™ä¸ªå˜é‡æœ¬èº«ã€‚å› æ­¤ï¼Œå³ä½¿åœ¨å¤–éƒ¨æ”¹å˜äº† `capturedValue` çš„å€¼ï¼Œé—­åŒ…ä¹Ÿæ— æ³•çœ‹åˆ°è¿™ä¸ªæ”¹å˜ã€‚

å…¶ä¸­ç¬¬äºŒä¸ªä¾‹å­, å’Œä¸‹é¢çš„å†™æ³•æ˜¯ç­‰ä»·çš„: 

ä¹Ÿå°±æ˜¯ä¸ä½¿ç”¨Capture List åŠŸèƒ½çš„å†™æ³•, æ˜¾ç„¶Capture List å†™æ³•æ›´åŠ ç®€æ´:

```swift
        var capturedValue: Int = 0
        let capturedValueForClosure = capturedValue  // è¿™é‡Œç›¸å½“äº Capture List ä¸­çš„ [capturedValue]

        let valueCaptureListClosure = {
            print(capturedValueForClosure)  // åœ¨é—­åŒ…ä¸­ä½¿ç”¨çš„æ˜¯ capturedValueForClosure çš„å€¼
        }

        capturedValue = 1

        valueCaptureListClosure()  // æ‰“å°0ï¼Œè¯´æ˜é—­åŒ…çœ‹åˆ°çš„æ˜¯æ•è·æ—¶çš„ capturedValue çš„å€¼ï¼Œè€Œä¸æ˜¯å½“å‰çš„å€¼

```

è¿™é‡Œçš„ `capturedValueForClosure` çš„è¡Œä¸ºæ¨¡æ‹Ÿäº† Capture List ä¸­çš„ `capturedValue`ã€‚å³ï¼Œé—­åŒ…å†…éƒ¨ä½¿ç”¨çš„ `capturedValue` å®é™…ä¸Šæ˜¯åœ¨é—­åŒ…åˆ›å»ºæ—¶å°±è¢«æ•è·çš„ `capturedValueForClosure`ï¼Œè€Œä¸æ˜¯å¤–éƒ¨å˜é‡ `capturedValue`ï¼Œè¿™æ ·å°±å¯ä»¥ä¿è¯å³ä½¿å¤–éƒ¨çš„ `capturedValue` æ”¹å˜äº†ï¼Œé—­åŒ…å†…éƒ¨çš„ `capturedValue` ä¹Ÿä¸ä¼šå—å½±å“ã€‚è¿™ä¾‹å­ä¹Ÿå¯ä»¥è§£é‡Š Capture List çš„å·¥ä½œåŸç†ã€‚

è¿™ä¸ªç¡®å®æœ‰ç‚¹åç›´è§‰, æ²¡äººä¼šé¢„æœŸä»£ç ä¼šè¿™ä¹ˆè¿è¡Œ, æ‰€ä»¥åœ¨å¼€å‘ä¸­è¦é¿å…è¿™ç§åœºæ™¯çš„ä½¿ç”¨,

å½“ç„¶ä¹Ÿä¸ç”¨è¿‡äºæ‹…å¿ƒ, ä¹‹æ‰€ä»¥å¹³æ—¶æˆ‘ä»¬ä¸ä¼šç»å¸¸é‡åˆ°è¿™ä¸ªé—®é¢˜, æ˜¯å› ä¸ºæˆ‘ä»¬ç»å¸¸ä½¿ç”¨ä¸‹é¢çš„ç”¨æ³•, ä¹Ÿå°±æ˜¯
å¦‚æœä½ æ²¡æœ‰åœ¨æ•è·åˆ—è¡¨ä¸­æ˜ç¡®æŒ‡å®šæ•è·æ–¹å¼ï¼ŒSwift çš„é—­åŒ…ä¼š"æ‡’æ•è·â€(lazy capture) è¿™äº›å˜é‡ï¼Œè¿™æ„å‘³ç€å®é™…çš„å€¼æ•è·åªä¼šåœ¨é—­åŒ…é¦–æ¬¡æ‰§è¡Œæ—¶è¿›è¡Œã€‚è¿™æ ·ï¼Œå¦‚æœè¯¥å˜é‡åœ¨é—­åŒ…åˆ›å»ºä¹‹åä½†åœ¨é—­åŒ…æ‰§è¡Œä¹‹å‰è¢«ä¿®æ”¹ï¼Œé—­åŒ…å†…å°†ä½¿ç”¨è¯¥æœ€æ–°çš„å€¼

å‚è€ƒä»¥ä¸‹ä»£ç :



```swift
        var capturedValue: Int = 0

        let valueCaptureListClosure = {
            print(capturedValue)  // åœ¨é—­åŒ…ä¸­ä½¿ç”¨çš„æ˜¯ capturedValueForClosure çš„å€¼
        }

        capturedValue = 1

        valueCaptureListClosure()  // æ‰“å°1 è¯´æ˜é—­åŒ…çœ‹åˆ°çš„æ˜¯å½“å‰çš„ capturedValue çš„å€¼ 
```
    
    
ä½†åŸºäºä¸Šé¢æåˆ°çš„ç§ç§é—®é¢˜, é‚£ä¹ˆåº”è¯¥å¦‚ä½•å°½é‡è§„é¿è¿™ç§æƒ…å†µ, è¯·çœ‹ä¸‹é¢çš„ä¾‹å­:


---

ç¬¬3ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å°†å…¶å‘½åä¸º "referenceCaptureExample":

```swift
class CapturedClass {
    var value: Int = 0
}

var capturedInstance: CapturedClass? = CapturedClass()

let referenceCaptureClosure = {
    print(capturedInstance?.value ?? -1)
}

capturedInstance?.value = 1

referenceCaptureClosure()  // æ‰“å°1ï¼Œè¯´æ˜é—­åŒ…çœ‹åˆ°çš„æ˜¯ capturedInstance çš„å½“å‰çŠ¶æ€

```

- "referenceCaptureExample"ï¼ˆå¼•ç”¨æ•è·ç¤ºä¾‹ï¼‰: åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`capturedInstance` æ˜¯ä¸€ä¸ªå¼•ç”¨ç±»å‹ï¼ˆç±»çš„å®ä¾‹ï¼‰ã€‚å°½ç®¡æ²¡æœ‰æŒ‡å®šæ•è·åˆ—è¡¨ï¼Œä½†æ˜¯ç”±äºå®ƒæ˜¯å¼•ç”¨ç±»å‹ï¼Œæ‰€ä»¥é—­åŒ…æ•è·çš„æ˜¯è¿™ä¸ªå¼•ç”¨çš„å‰¯æœ¬ã€‚å› æ­¤ï¼Œå³ä½¿åœ¨å¤–éƒ¨æ”¹å˜äº†è¿™ä¸ªå®ä¾‹çš„å±æ€§ï¼Œé—­åŒ…ä¹Ÿèƒ½çœ‹åˆ°è¿™ä¸ªæ”¹å˜ã€‚


æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¾—å‡ºç»“è®º:

> å¦‚æœæƒ³è®©æ•è·çš„å€¼ï¼Œæ”¹å˜ä¹‹åï¼Œè¿˜èƒ½è®©é—­åŒ…å†…éƒ¨çŸ¥é“çš„è¯ï¼Œåªèƒ½é€šè¿‡å¼•ç”¨ç±»å‹.

---

ç¬¬å››ä¸ªä¾‹å­: 

```swift
var capturedValue: Int = 0

print(capturedValue)

let closure = {
    if capturedValue != 0 {
        capturedValue = 2
    }
}

capturedValue = 1

closure()

print(capturedValue)

```

è¿™æ®µä»£ç å’Œä¾‹å­Açš„å…³é”®åŒºåˆ«åœ¨äºï¼Œè¿™é‡Œçš„é—­åŒ… `closure` å¹¶æ²¡æœ‰ä½¿ç”¨ Capture List æ¥æ•è· `capturedValue` çš„åˆå§‹å€¼ï¼Œè€Œæ˜¯ç›´æ¥å¼•ç”¨äº† `capturedValue`ã€‚å› æ­¤ï¼Œé—­åŒ…ä¸­çš„ `capturedValue` å’Œå¤–éƒ¨çš„ `capturedValue` æ˜¯åŒä¸€ä¸ªå˜é‡ã€‚æ‰€ä»¥ï¼Œåœ¨è°ƒç”¨ `closure()` ä¹‹åï¼Œ`capturedValue` çš„å€¼è¢«æ”¹å˜ä¸º2ï¼Œè€Œä¸æ˜¯1ã€‚

æœ€åçš„ `print(capturedValue)` å°†ä¼šæ‰“å°å‡º `2`ï¼Œè€Œä¸æ˜¯ `0`ã€‚æ‰€ä»¥ï¼Œè™½ç„¶è¿™ä¸¤ä¸ªä¾‹å­åœ¨æŸäº›æ–¹é¢çœ‹èµ·æ¥ç±»ä¼¼ï¼ˆéƒ½æ¶‰åŠåˆ°äº†é—­åŒ…å’Œå˜é‡çš„ä¿®æ”¹ï¼‰ï¼Œä½†å®é™…ä¸Šå®ƒä»¬çš„è¡Œä¸ºæ˜¯ä¸åŒçš„ã€‚è¿™ä¹Ÿæ˜¯ Capture List åœ¨ Swift é—­åŒ…ä¸­çš„é‡è¦æ€§ï¼šä½¿ç”¨ Capture List å¯ä»¥æ§åˆ¶é—­åŒ…æ•è·å˜é‡çš„è¡Œä¸ºï¼Œä½¿å…¶åœ¨éœ€è¦çš„æ—¶å€™ç‹¬ç«‹äºå¤–éƒ¨å˜é‡ã€‚


## What is memory leak ? how to solve?

## æ•°æ®å¤„ç†ã€è¯­è¨€å®‰å…¨ã€ **è®¿é—®æƒé™ï¼š**

## Please implement a convenience init method for a subclass.

Sure, let's assume that you have a parent class named `Person` and a subclass named `Employee`.

```
class Person {
    var name: String
    var age: Int

    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
}

class Employee: Person {
    var jobTitle: String
    var salary: Int

    init(name: String, age: Int, jobTitle: String, salary: Int) {
        self.jobTitle = jobTitle
        self.salary = salary
        super.init(name: name, age: age)
    }

    // convenience init
    convenience init(name: String, jobTitle: String) {
        self.init(name: name, age: 0, jobTitle: jobTitle, salary: 0)
    }
}
```

The convenience initializer is used here to create a new `Employee` instance, and it only requires the `name` and `jobTitle` parameters. It calls the designated initializer with the provided name, jobTitle, and default values for `age` and `salary`.

In this case, an interviewer may follow up by asking why you used a convenience initializer and what the benefits are. Here are some points you might mention:

1. Convenience initializers can simplify the creation of an object by reducing the number of parameters that need to be passed when creating an object.
2. They can provide default values for certain properties to allow for quick and simple object creation in specific cases.
3. They promote code reusability, as you can have multiple convenience initializers that call the same designated initializer with different default parameters.
4. They help make the code cleaner and more readable by abstracting away the complexity of fully initializing an object.

please use convenience init to update those code below, and change objective-c code to swift code:

```
typedef NS_ENUM(NSInteger, CYLGender) {
       CYLGenderUndefined,
       CYLGenderMale,
       CYLGenderFemale
   };

   @interface CYLUser : NSObject<NSCopying>

   @property (nonatomic, readonly, copy) NSString *name;
   @property (nonatomic, readonly, assign) NSUInteger age;
   @property (nonatomic, readwrite, assign) CYLGender gender;

   - (instancetype)initWithName:(NSString *)name age:(NSUInteger)age gender:(CYLGender)gender;
   - (instancetype)initWithName:(NSString *)name age:(NSUInteger)age;
   + (instancetype)userWithName:(NSString *)name age:(NSUInteger)age gender:(CYLGender)gender;

   @end

```

Sure, I can help with that. Here is the equivalent Swift code:

```
import Foundation

enum CYLGender: Int {
    case undefined
    case male
    case female
}

class CYLUser: NSObject, NSCopying {

    let name: String
    let age: Int
    var gender: CYLGender

    init(name: String, age: Int, gender: CYLGender) {
        self.name = name
        self.age = age
        self.gender = gender
    }

    convenience init(name: String, age: Int) {
        self.init(name: name, age: age, gender: .undefined)
    }

    static func user(name: String, age: Int, gender: CYLGender) -> CYLUser {
        return CYLUser(name: name, age: age, gender: gender)
    }

    func copy(with zone: NSZone? = nil) -> Any {
        let copy = CYLUser(name: name, age: age, gender: gender)
        return copy
    }
}

```

In this code:

1. We define an enum `CYLGender` to represent the gender of a user, with cases for undefined, male, and female.
2. We define a class `CYLUser` that has properties for `name`, `age`, and `gender`.
3. We define an initializer that takes `name`, `age`, and `gender` as parameters and assigns them to the respective properties.
4. We define a convenience initializer that takes `name` and `age` as parameters and calls the designated initializer with `gender` set to `undefined`.
5. We define a static function `user` that takes `name`, `age`, and `gender` as parameters and returns a new instance of `CYLUser`.
6. We also make `CYLUser` conform to the `NSCopying` protocol by providing an implementation of the `copy(with:)` method. In this method, we simply create and return a new `CYLUser` with the same `name`, `age`, and `gender` as the current instance.

## 14ã€Swift çš„å®‰å…¨æ€§

1ï¼‰ä»£ç å®‰å…¨
let å±æ€§Â - ä½¿â½¤ let ç”³æ˜å¸¸é‡é¿å…è¢«ä¿®æ”¹ã€‚
å€¼ç±»å‹Â - å€¼ç±»å‹å¯ä»¥é¿å…åœ¨â½…æ³•è°ƒâ½¤ç­‰å‚æ•°ä¼ é€’è¿‡ç¨‹ä¸­çŠ¶æ€è¢«ä¿®æ”¹ã€‚
è®¿é—®æ§åˆ¶Â - é€šè¿‡ public å’Œ final é™åˆ¶æ¨¡å—å¤–ä½¿â½¤ class ä¸èƒ½è¢«ç»§æ‰¿å’Œé‡å†™ã€‚
å¼ºåˆ¶å¼‚å¸¸å¤„ç†Â - â½…æ³•éœ€è¦æŠ›å‡ºå¼‚å¸¸æ—¶ï¼Œéœ€è¦ç”³æ˜ä¸º throw â½…æ³•ã€‚å½“è°ƒâ½¤å¯èƒ½ä¼š throw å¼‚å¸¸çš„â½…æ³•ï¼Œéœ€è¦å¼ºåˆ¶æ•è·å¼‚
å¸¸é¿å…å°†å¼‚å¸¸æš´éœ²åˆ°ä¸Šå±‚ã€‚
æ¨¡å¼åŒ¹é…Â - é€šè¿‡æ¨¡å¼åŒ¹é…æ£€æµ‹ switch ä¸­æœªå¤„ç†çš„ caseã€‚
2ï¼‰ç±»å‹å®‰å…¨
å¼ºåˆ¶ç±»å‹è½¬æ¢Â - ç¦â½Œéšå¼ç±»å‹è½¬æ¢é¿å…è½¬æ¢ä¸­å¸¦æ¥çš„å¼‚å¸¸é—®é¢˜ã€‚åŒæ—¶ç±»å‹è½¬æ¢ä¸ä¼šå¸¦æ¥é¢å¤–çš„è¿â¾æ—¶æ¶ˆè€—ã€‚ã€‚
æç¤ºï¼šç¼–å†™ObjCä»£ç æ—¶ï¼Œæˆ‘ä»¬é€šå¸¸ä¼šåœ¨ç¼–ç æ—¶æ·»åŠ ç±»å‹æ£€æŸ¥é¿å…è¿â¾æ—¶å´©æºƒå¯¼è‡´Crashã€‚
KeyPathÂ -Â KeyPath ç›¸â½ä½¿â½¤å­—ç¬¦ä¸²å¯ä»¥æä¾›å±æ€§åå’Œç±»å‹ä¿¡æ¯ï¼Œå¯ä»¥åˆ©â½¤ç¼–è¯‘å™¨æ£€æŸ¥ã€‚
æ³›å‹Â - æä¾›æ³›å‹å’Œåè®®å…³è”ç±»å‹ï¼Œå¯ä»¥ç¼–å†™å‡ºç±»å‹å®‰å…¨çš„ä»£ç ã€‚ç›¸â½ Any å¯ä»¥æ›´å¤šåˆ©â½¤ç¼–è¯‘æ—¶æ£€æŸ¥å‘ç°ç±»å‹é—®é¢˜ã€‚
Enum å…³è”ç±»å‹Â - é€šè¿‡ç»™ç‰¹å®šæšä¸¾æŒ‡å®šç±»å‹é¿å…ä½¿â½¤ Anyã€‚
3ï¼‰å†…å­˜å®‰å…¨
ç©ºå®‰å…¨Â - é€šè¿‡æ ‡è¯†å¯é€‰å€¼é¿å…ç©ºæŒ‡é’ˆå¸¦æ¥çš„å¼‚å¸¸é—®é¢˜
ARCÂ - ä½¿â½¤â¾ƒåŠ¨å†…å­˜ç®¡ç†é¿å…â¼¿åŠ¨ç®¡ç†å†…å­˜å¸¦æ¥çš„å„ç§å†…å­˜é—®é¢˜
å¼ºåˆ¶åˆå§‹åŒ–Â - å˜é‡ä½¿â½¤å‰å¿…é¡»åˆå§‹åŒ–
å†…å­˜ç‹¬å è®¿é—®Â - é€šè¿‡ç¼–è¯‘å™¨æ£€æŸ¥å‘ç°æ½œåœ¨çš„å†…å­˜å†²çªé—®é¢˜
4ï¼‰çº¿ç¨‹å®‰å…¨
å€¼ç±»å‹Â - æ›´å¤šä½¿â½¤å€¼ç±»å‹å‡å°‘åœ¨å¤šçº¿ç¨‹ä¸­é‡åˆ°çš„æ•°æ®ç«äº‰é—®é¢˜
async/awaitÂ - æä¾› async å‡½æ•°ä½¿æˆ‘ä»¬å¯ä»¥â½¤ç»“æ„åŒ–çš„â½…å¼ç¼–å†™å¹¶å‘æ“ä½œã€‚é¿å…åŸºäºé—­åŒ…çš„å¼‚æ­¥â½…å¼å¸¦æ¥çš„å†…å­˜å¾ªç¯
å¼•â½¤å’Œâ½†æ³•æŠ›å‡ºå¼‚å¸¸çš„é—®é¢˜
ActorÂ - æä¾› Actor æ¨¡å‹é¿å…å¤šçº¿ç¨‹å¼€å‘ä¸­è¿›â¾æ•°æ®å…±äº«æ—¶å‘â½£çš„æ•°æ®ç«äº‰é—®é¢˜ï¼ŒåŒæ—¶é¿å…åœ¨ä½¿â½¤é”æ—¶å¸¦æ¥çš„æ­»é”ç­‰
é—®é¢˜
5ï¼‰å¿«é€Ÿ
å€¼ç±»å‹Â - ç›¸â½ class ä¸éœ€è¦é¢å¤–çš„å †å†…å­˜åˆ†é… / é‡Šæ”¾å’Œæ›´å°‘çš„å†…å­˜æ¶ˆè€—
â½…æ³•é™æ€æ´¾å‘Â - â½…æ³•è°ƒâ½¤â½€æŒé™æ€è°ƒâ½¤ç›¸â½åŸæœ‰ ObjC æ¶ˆæ¯è½¬å‘è°ƒâ½¤æ€§èƒ½æ›´å¥½
ç¼–è¯‘å™¨ä¼˜åŒ–Â - Swift çš„é™æ€æ€§å¯ä»¥ä½¿ç¼–è¯‘å™¨åšæ›´å¤šä¼˜åŒ–ã€‚ä¾‹å¦‚ Tree Shaking ç›¸å…³ä¼˜åŒ–ç§»é™¤æœªä½¿â½¤çš„ç±»å‹ / â½…æ³•ç­‰å‡å°‘
â¼†è¿›åˆ¶â½‚ä»¶â¼¤â¼©ã€‚ä½¿â½¤é™æ€æ´¾å‘ / â½…æ³•å†…è”ä¼˜åŒ– / æ³›å‹ç‰¹åŒ– / å†™æ—¶å¤åˆ¶ç­‰ä¼˜åŒ–æâ¾¼è¿â¾æ—¶æ€§èƒ½
æç¤ºï¼šObjCæ¶ˆæ¯æ´¾å‘ä¼šå¯¼è‡´ç¼–è¯‘å™¨â½†æ³•è¿›â¾ç§»é™¤â½†â½¤â½…æ³•/ç±»çš„ä¼˜åŒ–ï¼Œç¼–è¯‘å™¨å¹¶ä¸çŸ¥é“æ˜¯å¦å¯èƒ½è¢«â½¤åˆ°ã€‚
ARC ä¼˜åŒ–Â - è™½ç„¶å’Œ ObjC â¼€æ ·éƒ½æ˜¯ä½¿â½¤ ARCï¼ŒSwift é€šè¿‡ç¼–è¯‘å™¨ä¼˜åŒ–ï¼Œå¯ä»¥è¿›â¾æ›´å¿«çš„å†…å­˜å›æ”¶å’Œæ›´å°‘çš„å†…å­˜å¼•â½¤è®¡
æ•°ç®¡ç†
æç¤ºï¼š ç›¸â½ObjCï¼ŒSwiftå†…éƒ¨ä¸éœ€è¦ä½¿â½¤autoreleaseè¿›â¾ç®¡ç†ã€‚

1. è¯·è§£é‡Š Swift ä¸­çš„è®¿é—®æƒé™å¦‚ä½•è®¾ç½®ï¼Œä»¥åŠä¸åŒè®¿é—®çº§åˆ«ä¹‹é—´çš„åŒºåˆ«ï¼Ÿ

## 13ã€Swift Try catch çš„åŸç†ï¼Ÿ

## 15. How do you filter an array of instances to extract a specific property in Swift?

[https://chat.openai.com/share/05a875de-5e3b-4257-b68b-f296c218f16d](https://chat.openai.com/share/05a875de-5e3b-4257-b68b-f296c218f16d)

![swift_map_type_diff_en](../assets/swift_map_type_diff_en.jpg)
![swift_map_type_diff_cn](../assets/swift_map_type_diff_cn.jpg)




## Difference between map, flatMap and compactMap in Swift

è¿™æ®µä»£ç â½¤äº†å“ªäº›è¯­æ³•ç³–ï¼Ÿ 

```swift
[1, 2, 3].map{ $0 * 2 }
```

1ã€å¿«é€Ÿåˆ›å»ºæ•°ç»„ï¼›
2ã€åœ¨æ²¡æœ‰å£°æ˜å‚æ•°åˆ—è¡¨æ—¶ï¼Œç¬¬â¼€ä¸ªå‚æ•°â½¤ $0 ä»£æ›¿ï¼Œåâ¾¯ä¾æ¬¡ç±»æ¨ï¼›
3ã€é—­åŒ…æ²¡æœ‰å£°æ˜å‡½æ•°å‚æ•°, è¿”å›å€¼ç±»å‹, æ•°é‡, ä¾é çš„æ˜¯é—­åŒ…ç±»å‹çš„â¾ƒåŠ¨æ¨æ–­ï¼›
4ã€é—­åŒ…ä¸­è¯­å¥åªæœ‰â¼€å¥æ—¶, â¾ƒåŠ¨å°†è¿™â¼€å¥çš„ç»“æœä½œä¸ºè¿”å›å€¼ï¼›

Swift ä¸­ map, flatMap and compactMap çš„åŒºåˆ«æ˜¯ä»€ä¹ˆ?

What is their difference? what is the  best situation to use on of them?

The `flatMap` and `compactMap` functions in Swift are used to transform and filter optionals and collections.

**flatMap**:

In Swift, `flatMap` has two main use cases:

1. It can be used with optionals. It works by transforming the optional if it is not `nil` or just returning `nil`. This use of `flatMap` was deprecated in Swift 4.1.
2. It can be used with collections. `flatMap` operates on a collection (for example, an array of arrays), and "flattens" the result into a single array after applying a transformation. For example, given an array of arrays, it will apply the transformation to all elements and flatten the result into a single array.

```
let nestedArray = [[1, 2, 3], [4, 5, 6]]
let flattenedArray = nestedArray.flatMap { $0 }
print(flattenedArray) // Output: [1, 2, 3, 4, 5, 6]

```

**compactMap**:

`compactMap` is used to transform the elements of a sequence while simultaneously unwrapping optionals and removing nil results. This makes `compactMap` a great choice when transforming a collection where the transformation might return an optional.

Here's an example of `compactMap` in action:

```
let numbers = ["1", "2", "three", "4"]
let mappedNumbers = numbers.compactMap { Int($0) }
print(mappedNumbers) // Output: [1, 2, 4]

```

In this example, attempting to convert "three" to an `Int` results in `nil`, which `compactMap` removes from the final array.

As to which to use, it depends on your needs:

- If you have a transformation that returns an optional and you want to remove `nil` values, use `compactMap`.
- If you need to flatten a collection of collections, use `flatMap`.
- If you have an optional and want to transform it if it's not `nil`, you'd previously use `flatMap`, but this is now done using `Optional.map` as of Swift 4.1.

Remember, both `flatMap` and `compactMap` do not mutate the original array. They return new arrays, which is a characteristic of functional programming.


ä¸Šé¢è®¨è®ºçš„æ˜¯Swiftæ•°ç»„å’Œé›†åˆmapï¼ŒflatMapå’ŒcompactMapåŸºæœ¬æ“ä½œï¼Œå®ƒä»¬ç”¨äºå¯¹é›†åˆä¸­çš„å…ƒç´ è¿›è¡Œè½¬æ¢å’Œè¿‡æ»¤ã€‚è¿™äº›å‡½æ•°å¯¹äºå¤„ç†åŒæ­¥æ“ä½œå’Œæ•°æ®éå¸¸æœ‰ç”¨ã€‚

åŒæ—¶ï¼ŒCombineæ¡†æ¶ä¸­ä¹Ÿå­˜åœ¨`map`ï¼Œ`flatMap`å’Œ`compactMap`çš„ä½¿ç”¨ã€‚
![swift-combine](../assets/swift-combine.jpg)

Swift Combineæ¡†æ¶æ˜¯ä¸€ä¸ªå“åº”å¼ç¼–ç¨‹æ¡†æ¶ï¼Œå®ƒå¯ä»¥å¤„ç†å¼‚æ­¥äº‹ä»¶ï¼Œä¾‹å¦‚ç”¨æˆ·äº¤äº’ï¼Œç½‘ç»œå“åº”ç­‰ã€‚Combineä½¿ç”¨äº†å‘å¸ƒè€…å’Œè®¢é˜…è€…æ¨¡å‹ï¼Œå‘å¸ƒè€…å‘å¸ƒäº‹ä»¶ï¼Œè®¢é˜…è€…æ¥æ”¶å¹¶å¤„ç†è¿™äº›äº‹ä»¶ã€‚

Combineæ¡†æ¶ä¸­ä¹Ÿæœ‰`map`ï¼Œ`flatMap`å’Œ`compactMap`æ“ä½œç¬¦ï¼Œä½†è¿™äº›æ“ä½œç¬¦é€‚ç”¨äºå¤„ç†å¼‚æ­¥äº‹ä»¶æµã€‚è¿™äº›æ“ä½œç¬¦çš„è¡Œä¸ºä¸æ•°ç»„å’Œé›†åˆä¸Šçš„æ“ä½œéå¸¸ç›¸ä¼¼ï¼š

- `map`ï¼šæ¥æ”¶ä¸€ä¸ªè½¬æ¢é—­åŒ…ï¼Œå°†æ¥æ”¶åˆ°çš„æ¯ä¸ªè¾“å…¥äº‹ä»¶è½¬æ¢ä¸ºæ–°çš„å€¼æˆ–äº‹ä»¶ã€‚
- `flatMap`ï¼šæ¥æ”¶ä¸€ä¸ªè¿”å›Publisherçš„è½¬æ¢é—­åŒ…ï¼Œå°†æ¥æ”¶åˆ°çš„æ¯ä¸ªè¾“å…¥äº‹ä»¶è½¬æ¢ä¸ºä¸€ä¸ªæ–°çš„Publisherã€‚ç„¶åï¼Œè¿™äº›æ–°çš„Publisherçš„äº‹ä»¶è¢«åˆå¹¶åˆ°ä¸€ä¸ªå…±äº«çš„äº‹ä»¶æµä¸­ã€‚
- `compactMap`ï¼šä¸`map`æ“ä½œç±»ä¼¼ï¼Œä½†ä¼šå¿½ç•¥è½¬æ¢é—­åŒ…è¿”å›çš„nilå€¼ã€‚

æ‰€ä»¥è¯´ï¼Œ`map`ï¼Œ`flatMap`å’Œ`compactMap`åœ¨Swiftçš„åŸºç¡€é›†åˆå’ŒCombineæ¡†æ¶ä¸­éƒ½æœ‰ä½¿ç”¨ï¼Œå®ƒä»¬éƒ½æ˜¯å¯¹å…ƒç´ è¿›è¡Œè½¬æ¢å’Œè¿‡æ»¤çš„æ“ä½œï¼Œä½†Combineæ¡†æ¶ä¸­çš„è¿™äº›æ“ä½œæ˜¯åº”ç”¨åœ¨å¼‚æ­¥äº‹ä»¶æµä¸Šçš„ã€‚


ä»£ç æ¼”ç¤ºå¦‚ä¸‹ï¼š

æ³¨æ„ï¼Œè¿™éœ€è¦Swift 5.0åŠæ›´é«˜ç‰ˆæœ¬ï¼Œå¹¶ä¸”éœ€è¦å¯¼å…¥Combineåº“ã€‚

```swift
import Combine

// Create a publisher
let numbersPublisher = [1, 2, 3, 4, 5].publisher

// map
numbersPublisher
    .map { $0 * 10 }
    .sink { print($0) }  // Output: 10, 20, 30, 40, 50

// flatMap
let nestedPublisher = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].publisher
nestedPublisher
    .flatMap { $0.publisher }
    .sink { print($0) }  // Output: 1, 2, 3, 4, 5, 6, 7, 8, 9

// compactMap
let publisherWithNil = [1, nil, 3, nil, 5].publisher
publisherWithNil
    .compactMap { $0 }
    .sink { print($0) }  // Output: 1, 3, 5
```

è¯·æ³¨æ„ï¼Œä»¥ä¸Š Combine ç¤ºä¾‹æ˜¯ç®€åŒ–çš„ï¼Œå¹¶ä¸”ä¸åŒ…å«å–æ¶ˆè®¢é˜…çš„é€»è¾‘ï¼Œå®é™…å¼€å‘ä¸­éœ€è¦æ­£ç¡®åœ°å¤„ç†å’Œå–æ¶ˆè®¢é˜…ã€‚


#### 3. The time complexity of the map, filter, and reduce
O(n)

## 6ã€Swift çš„è®¡ç®—å±æ€§ã€å­˜å‚¨å±æ€§ã€æ‡’åŠ è½½

1ï¼‰è®¡ç®—å±æ€§ï¼ˆComputed Variableï¼‰
ä»…æœ‰ get ( readOnly) æˆ–æœ‰ get+set çš„å±æ€§æ˜¯è®¡ç®—å‹å±æ€§ï¼ŒçœŸæ­£èµ‹å€¼çš„è¿‡ç¨‹æ˜¯å­˜åœ¨äº set â½…æ³•ä¸­å¹¶è¢«åº•å±‚åŒ…è£…æ‰çš„ï¼Œå¦‚æœ
æˆ‘ä»¬â¼¿åŠ¨å®ç°äº†set â½…æ³•ï¼Œå°±â½†æ³•è¿›â¾æ­£ç¡®çš„èµ‹å€¼ã€‚ï¼ˆæ­¤å¤„è·Ÿ OC ä¸â¼€æ ·ï¼‰

```swift
1private var _squre: Double = 0.0
2var squre: Double {
3Â  Â  get {
4Â  Â  Â  Â  return *squre
5Â  Â  }
6Â  Â  set {
7Â  Â  Â  Â  if (newValue "<= 0) {
8Â  Â  Â  Â  Â  Â  print("newValue = \(newValue)")
9Â  Â  Â  Â  } else {
10Â  Â  Â  Â  Â  Â  squre = newValue
11Â  Â  Â  Â  }
12Â  Â  }
13}*
```

*2ï¼‰å­˜å‚¨å±æ€§ï¼ˆSorted Variableï¼‰*

```swift
*1class Test {
2Â  Â  init(width: Double) {
3Â  Â  Â  Â  self.width = width "// æ­¤å¤„ä¸ä¼šè°ƒâ½¤ willset ã€didset â½…æ³•
4Â  Â  Â  Â  setValue(width, forKey: "width") "// KVC å¯ä»¥è°ƒâ½¤
5Â  Â  }
6Â  Â  var width: Double {
7Â  Â  Â  Â  willSet {
8Â  Â  Â  Â  Â  Â  print("willSetâ½…æ³•è¢«è°ƒâ½¤")
9Â  Â  Â  Â  Â  Â  print("åœ¨willSetä¸­ï¼Œwidth = \(width),newValue = \(newValue)")
10Â  Â  Â  Â  }
11Â  Â  Â  Â 
12Â  Â  Â  Â  didSet {
13Â  Â  Â  Â  Â  Â  print("didSetâ½…æ³•è¢«è°ƒâ½¤")
14Â  Â  Â  Â  Â  Â  print("åœ¨didSetä¸­ï¼Œwidth = \(width),oldValue = \(oldValue)")
15Â  Â  Â  Â  }
16Â  Â  }
17}*
```

*3ï¼‰æ‡’åŠ è½½ï¼ˆLazy Loadï¼‰ å’Œè®¡ç®—å±æ€§çš„åŒºåˆ«*

*è®¡ç®—å±æ€§ï¼š*

- *æ¯æ¬¡éƒ½ä¼šè®¡ç®—*
- *ä¸åˆ†é…ç‹¬â½´ç©ºé—´*

*æ‡’åŠ è½½*

**

- *æœ¬è´¨æ˜¯ä¸ªé—­åŒ…ï¼Œåˆ†é…å†…å­˜ç©ºé—´*
- *åœ¨â¾¸æ¬¡æ‰§â¾æ—¶ï¼Œè¿”å›é—­åŒ…çš„å€¼*

*å’Œ OC ä¸åŒçš„æ˜¯ï¼Œ Swift çš„æ‡’åŠ è½½ï¼Œç½®ç©ºåä¸ä¼šé‡æ–°è°ƒâ½¤ã€‚*

**

## *9ã€Sequence / â¾¼é˜¶å‡½æ•° / Collection*

*Swift çš„ Collections ï¼ˆSequence åè®®ï¼‰*

**

## 12ã€æ··ç¼–è¿‡ç¨‹ä¸­é‡åˆ°çš„ Crash

1ï¼‰@objc åˆ«å MBCCC ï¼Œå¯¹åº” CCC xibï¼ŒiOS 12 ä»¥ä¸‹ é—ªé€€ï¼›
2ï¼‰æ··ç¼–Â  æ²¡åŠ  nullable åˆ° swift ä¸åšè§£åŒ… ä¼šå´©æºƒäº†ï¼›
3ï¼‰OC æœ‰ä¸ª ivarï¼ŒSwift abi ç¨³å®šï¼Œâ¼†è¿›åˆ¶æœ‰è„†å¼±æ€§ï¼›å¦‚æœåº“çš„ä½œè€…æ”¹å˜äº†å¯¹è±¡å†…å…¬å…±å­—æ®µçš„â¼¤â¼©æˆ–å¸ƒå±€ï¼Œåç§»é‡å°±â½†æ•ˆ
äº†ï¼Œç¨‹åºå°±æ²¡æ³•æ­£å¸¸è¿â¾ï¼›ï¼ˆè§£å†³â½…æ¡ˆï¼šéœ€è¦å…¨é‡ç¼–è¯‘ã€æˆ–å¼•â½¤åˆ°è¿™ä¸ªåº“çš„ä¸Šå±‚åº“é‡æ–°ç¼–è¯‘ã€‚ï¼‰

## é¢å‘å¯¹è±¡

## 1ã€Swift å¯¹è±¡å’Œ OC å¯¹è±¡çš„åŒºåˆ«
![6](assets/6.jpg)

1ï¼‰åˆå§‹åŒ–
åˆå§‹åŒ– OC é»˜è®¤ç½®ç©ºï¼Œå¯ä»¥â½—ç±» -> â¼¦ç±» ï¼ˆé€šè¿‡ super.initï¼‰
Swift å¿…é¡»èµ‹å€¼ï¼Œâ¼¦ç±» -> â½—ç±»ï¼ˆå¿…é¡»ç»™â¼¦ç±»æ‰€æœ‰å±æ€§èµ‹å€¼ï¼Œæ‰èƒ½è°ƒâ½¤ super.initï¼‰
å…¶ä»–ï¼š
å®šä¹‰å˜é‡ã€å±æ€§ã€åè®®ï¼Œä¸¤è€…ç±»ä¼¼ã€‚

2ï¼‰Swift å¯¹è±¡åŒ…æ‹¬ classã€enumã€struct
enum å’Œ struct éƒ½æ˜¯å€¼å¼•â½¤ -> å¯ä»¥å¼•å‡ºé—®é¢˜ï¼šå†™æ—¶å¤åˆ¶ / struct â½ class æœ‰ä»€ä¹ˆä¼˜åŠ¿

3ï¼‰â½…æ³•æ´¾å‘
Swift ç›´æ¥æ´¾å‘ï¼Œæ²¡æœ‰ isa é‚£â¼€æ®µï¼ŒOC è¦é€šè¿‡ isa æŸ¥æ‰¾ï¼›
[https://www.jianshu.com/p/91bfe3f11eec](https://www.jianshu.com/p/91bfe3f11eec) ï¼ŒSwift çš„æ¶ˆæ¯æ´¾å‘ï¼Œæµ“ç¼©åœ¨ä¸‹â¾¯çš„è¡¨â¾¥äº†.

runtime ä¹‹æ¶ˆæ¯è½¬å‘:

- æ¶ˆæ¯å‘é€ï¼ˆç¼“å­˜+å‡½æ•°è¡¨æŸ¥æ‰¾ï¼Œå¾€â½—ç±»æŸ¥æ‰¾ï¼‰
- åŠ¨æ€â½…æ³•è§£æï¼ˆåŠ¨æ€ç¼“å­˜ï¼Œclass_addMethod æ·»åŠ ï¼‰
- æ¶ˆæ¯è½¬å‘ ï¼ˆforwardingTargetForSelector / methodSignatureForSelector / doesNotRecognizeSelectorï¼‰

![](../assets/16911995736181.jpg)


| Swift â½…æ³•æ´¾å‘  | ç›´æ¥æ´¾å‘ Direct Dispatch  | å‡½æ•°è¡¨æ´¾å‘ Table Dispatch | æ¶ˆæ¯æœºåˆ¶ Message Dispatch è½¬åŒ–ä¸º objc_msgSend |
| --- | --- | --- | --- |
| NSObject |  @nonobjc or final  | Initial Declarationå‡½æ•°å†…éƒ¨è°ƒâ½¤ | Extensions dynamic |
| Class | Extensions final |   Initial Declaration å‡½æ•°å†…éƒ¨è°ƒâ½¤ | dynamic |
| Protocol  | Extensions |  Initial Declaration å‡½æ•°å†…éƒ¨è°ƒâ½¤ |  @objc |
| Value Type å€¼ç±»å‹ |  All methods | N/A | N/A |


[https://chat.openai.com/share/5ed1d819-48e0-4755-8e8c-5d3a6d0e7db6](https://chat.openai.com/share/5ed1d819-48e0-4755-8e8c-5d3a6d0e7db6)

```swift
//è¯·çŒœæµ‹æ‰“å°çš„ç»“æœ
// [2023-07-28 14:45:39] @iTeaTime(æŠ€æœ¯æ¸…è°ˆ)@ChenYilong
import UIKit

class BaseCell: UITableViewCell {
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}

extension BaseCell: ClassIdenfifiable {
    static var reuseIdentifier: String {
        return "default"
    }
    
    static var reuseIdentifier2: String {
        return "B"
    }
}
protocol ClassIdenfifiable {
    static var reuseIdentifier: String { get }
}

extension ClassIdenfifiable {
    static var reuseIdentifier: String {
        return String(describing: self)
    }
    //ä¸åœ¨ Protocol requirements ä¸­å£°æ˜
    static var reuseIdentifier2: String {
        return "A"
    }
}

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
        let aType: ClassIdenfifiable.Type = BaseCell.self
        print("aType.reuseIdentifier is ", aType.reuseIdentifier)
        print("aType.reuseIdentifier2 is ", aType.reuseIdentifier2)
        
        print("BaseCell.reuseIdentifier is ", BaseCell.reuseIdentifier)
        print("BaseCell.reuseIdentifier2 is ", BaseCell.reuseIdentifier2)
    }
    
}
```

åè®®å£°æ˜çš„æ–¹æ³•æ˜¯ä¸€å®šæœ‰æ­£ç¡®çš„è¡Œä¸ºçš„.æ‰€ä»¥æ— è®ºæ˜¯ä»€ä¹ˆä»€ä¹ˆæ–¹å¼è°ƒç”¨ï¼Œidä¸€å®šæ˜¯default, ä¸å¯¹ä½ å¯ä»¥æ‰¾è‹¹æœ. è‡³äºid2ï¼Œ å…¶å®æ˜¯ubçš„, undefined behavior æ¢å¥è¯æ¥è¯´ï¼Œä½ å¯ä»¥ç”¨ é™æ€æ´¾å‘ æ¥è§£é‡Šè¿™ä¸ªè¡Œä¸ºï¼Œä½†ä¸èƒ½å‡å®šä»–ä¸€å®šä¼šé™æ€æ´¾å‘

è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘è¯´ä»–æ˜¯ubçš„ï¼Œå› ä¸ºswiftçš„å›¢é˜Ÿéƒ½ä¸çŸ¥é“æ€ä¹ˆå¤„ç†

[](https://github.com/apple/swift/blob/main/docs/GenericsManifesto.md#maybe)

è€ƒå¯Ÿçš„æ˜¯Swiftæ–¹æ³•æ´¾å‘

[](https://github.com/apple/swift/blob/main/docs/GenericsManifesto.md#dynamic-dispatch-for-members-of-protocol-extensions)

| åŒºåˆ« | æ´¾å‘è¡Œä¸º | åˆ«ç§° |
| --- | --- | --- |
| Protocol Default Implementation | Dynamic Dispatch | Table Dispatch |
| æ™®é€š Extension | Static Dispatch | Direct Dispatch |

ç»†èŠ‚ï¼š
1ã€ SwiftÂ  åè®®å’Œç±»çš„ extension â¾¥çš„â½…æ³•ä½¿â½¤ç›´æ¥æ´¾å‘ï¼Œæ‰€ä»¥ä¸èƒ½è¢«é‡å†™ï¼›
2ã€NSObject çš„ extension ä¼šä½¿â½¤æ¶ˆæ¯æœºåˆ¶è¿›â¾æ´¾å‘ï¼ŒNSObject ä½œâ½¤åŸŸå†…çš„çš„æ˜¯å‡½æ•°è¡¨æ´¾å‘ï¼›
3ã€åè®®â¾¥å£°æ˜çš„, å¹¶ä¸”å¸¦æœ‰é»˜è®¤å®ç°çš„å‡½æ•°ä¼šä½¿â½¤å‡½æ•°è¡¨è¿›â¾æ´¾å‘ï¼›
4ã€æ¶ˆæ¯æ´¾å‘é€šè¿‡ç¼“å­˜æ¥è¾¾åˆ°è·Ÿå‡½æ•°è¡¨æ´¾å‘â¼€æ ·çš„æ•ˆç‡ï¼›
5ã€OC å¯ä»¥é€šè¿‡   `___**attribute__**((objc_direct))`   å®ç°ç›´æ¥æ´¾å‘ï¼›
6ã€Swift çš„æ´¾å‘åœ¨ SILï¼ˆSwift Intermediate Languageï¼‰ä¸­çš„è¡¨ç°ï¼š
ç›´æ¥æ´¾å‘ï¼ˆDirectï¼‰ï¼šåœ¨ SIL â½‚ä»¶ä¸­ï¼Œä»¥ function_refÂ çš„â½…å¼è·å–å‡½æ•°ï¼›
å‡½æ•°è¡¨æ´¾å‘ï¼ˆTableï¼‰ï¼šåœ¨ SIL â½‚ä»¶ä¸­ï¼Œä»¥Â class_methodÂ çš„â½…å¼ï¼Œé€šè¿‡ Vtable è·å–å‡½æ•°ï¼›
æ¶ˆæ¯è½¬å‘ï¼ˆMessageï¼‰ï¼šåœ¨ SIL â½‚ä»¶ä¸­ï¼Œä»¥Â  objc_methodÂ çš„â½…å¼è·å–å‡½æ•°ï¼›
åè®®è¡¨è°ƒåº¦ï¼ˆwitness_methodï¼‰ï¼šå®ç°äº†åè®®çš„ Swift ç±»ï¼Œé€šè¿‡ PWT æ‰¾åˆ° Vtable è¿›â¾è°ƒåº¦ï¼›
7ã€å‡½æ•°è¡¨æ´¾å‘çš„ Vtable å­˜åœ¨ metaData ä¸­ï¼›

// ClassIdenfifiable is Existential type

 **let** cell: ClassIdenfifiable = BaseCell()

![](../assets/16911995859741.jpg)

![](../assets/16911995927355.jpg)

![](../assets/16911996015251.jpg)



### **43. What is polymorphism?**

![](../assets/16911996112667.jpg)


Polymorphism is an essential building block of any object-oriented programming language. It uses a single symbol to represent many different kinds of entities or the availability of a single interface to entities of diverse types. With polymorphism, your code can operate on either the parent class or one of its offspring, depending on the supported hierarchy (family of objects).

## 5ã€ä¸é€šè¿‡ç»§æ‰¿ï¼Œä»£ç å¤â½¤ / å…±äº«çš„â½…å¼æœ‰å“ªäº›ï¼Ÿ

1ï¼‰swift â½‚ä»¶â¾¥çš„â½…æ³•åœ¨åŒ…â¾¥ public / open ç›¸å½“äºå…¨å±€å‡½æ•°ï¼›
2ï¼‰é€šè¿‡ protocol + protocol çš„æ‹“å±•é»˜è®¤å®ç°ï¼Œå®ç°è¿™ä¸ª protocol å°±å¯ä»¥æ‹¥æœ‰è¿™äº›ä»£ç çš„èƒ½â¼’ï¼›

## çˆ¶ç±»çš„åˆ†ç±»ä¸­å†™äº†ä¸€ä¸ªæ–¹æ³•, å­ç±»èƒ½å¦ç›´æ¥è°ƒç”¨ã€‚å‘ŠçŸ¥åŸå› ã€‚

| è°ƒç”¨æ¼”ç¤º | ç±»åˆ« | æ³¨æ„äº‹é¡¹ |
| --- | --- | --- |
| [self cyl_test]; | åˆ†ç±»å®ä¾‹æ–¹æ³• | å¿…é¡»åœ¨å­ç±»ä¸­æ‰‹åŠ¨ import çˆ¶ç±»çš„åˆ†ç±»,å¦åˆ™æŠ› ç¼–è¯‘é”™è¯¯âŒ |
| [self performSelector:@selector(cyl_test)]; | åˆ†ç±»å®ä¾‹æ–¹æ³• | å¿…é¡»åœ¨å­ç±»ä¸­æ‰‹åŠ¨ import çˆ¶ç±»çš„åˆ†ç±»,å¦åˆ™æŠ› warningâš ï¸ |
| [[self class] cyl_testClass]; | åˆ†ç±»ç±»æ–¹æ³• | å¿…é¡»åœ¨å­ç±»ä¸­æ‰‹åŠ¨ import çˆ¶ç±»çš„åˆ†ç±»,å¦åˆ™ç¼–è¯‘é”™è¯¯ âŒ |
| [[self class]performSelector:@selector(cyl_testClass)]; | åˆ†ç±»ç±»æ–¹æ³• | å¿…é¡»åœ¨å­ç±»ä¸­æ‰‹åŠ¨ import çˆ¶ç±»çš„åˆ†ç±»,å¦åˆ™æŠ› warningâš ï¸ |

## **é¢å‘åè®®ç¼–ç¨‹ï¼š**

What is a protocol and how can we benefit from it?
![1](assets/1-3.jpg)

**What is protocol extension? Why Swift called as Protocol Oriented Language?**

[What is protocol extension? Why Swift called as Protocol Oriented Language?](https://www.iosiqa.com/2020/04/what-is-protocol-extension-why-swift.html)

1. 
2. 

## 6. Can we add a property in a protocol? Can we put property in the protocol in Swift?

**What is protocol extension? Why Swift called as Protocol Oriented Language?

[https://chat.openai.com/share/5ed1d819-48e0-4755-8e8c-5d3a6d0e7db6](https://chat.openai.com/share/5ed1d819-48e0-4755-8e8c-5d3a6d0e7db6)

[What is protocol extension? Why Swift called as Protocol Oriented Language?](https://www.iosiqa.com/2020/04/what-is-protocol-extension-why-swift.html)

![](../assets/16911996216316.jpg)
![](../assets/16911996296998.jpg)



## 2ã€Swift çš„åè®®å’Œ OC çš„åè®®æœ‰ä»€ä¹ˆåŒºåˆ«
![4](assets/4.jpg)

1ï¼‰OC çš„åè®®â½¤æ¥å®ç°ä»£ç†ï¼›

2ï¼‰Swift åè®®å®šä¹‰äº†é€‚åˆç‰¹å®šä»»åŠ¡æˆ–åŠŸèƒ½çš„â½…æ³•ï¼Œå±æ€§ã€‚åè®®å¯ä»¥ç”±ç±»ï¼Œç»“æ„æˆ–æšä¸¾å®ç°ï¼Œä»»ä½•ç±»å‹å®ç°åè®®çš„è¦æ±‚
â½…æ³•ç§°ä¸ºéµå®ˆåè®®ï¼ˆâ¾¯å‘åè®®ã€æ¥â¼ç¼–ç¨‹ï¼‰ï¼›
1ã€åè®®ååŠ  : AnyObject å¯ä»¥è®©åè®®åªèƒ½è¢« Class å®ç°ï¼›
2ã€ä½¿â½¤ç±»çš„æ‹“å±•å¯ä»¥è®©ç°æœ‰çš„ç±»å®ç°åè®®ï¼›
3ã€ä½¿â½¤åè®®çš„æ‹“å±•ï¼Œå¯ä»¥è®©åè®®æœ‰é»˜è®¤å®ç°ï¼›
4ã€ç±»ä¼¼ OC çš„ @optional å®ç°ï¼ˆå¯¹äº 3ã€çš„åº”â½¤ï¼‰
æ¨èåœ¨ protocol çš„ extension â¾¥å®ç°é»˜è®¤â½…æ³•ï¼Œè¿™æ ·å°±ä¸å¿…å†™è¿™ä¸ªâ½…æ³•çš„å®ç°äº†ã€‚
æ··ç¼–çš„å¯ä»¥ @objcï¼›

3ï¼‰â¾¯å‘åè®®ç¼–ç¨‹ä¸â¾¯å‘å¯¹è±¡ç¼–ç¨‹ç›¸â½æœ‰ä»€ä¹ˆä¼˜ç¼ºç‚¹ï¼Ÿ
â¾¯å‘åè®®ï¼šå¯ä»¥å®ç°å¤šç»§æ‰¿ã€ä»£ç é‡å°‘ï¼Œä¸ä¼šæ±¡æŸ“ï¼Œä»£ç è€¦åˆæ€§ä½ ï¼›ç¼ºç‚¹ï¼šå¯è¯»æ€§ä½

4ï¼‰å¸¸â½¤åè®®ï¼š

OptionSet , å®ç°è¯¥åè®®å¯ä»¥å®ç° [.a, .b, .c] è¿™æ ·çš„æšä¸¾é›†åˆï¼Œç±»ä¼¼ C è¯­â¾” enum çš„æŒ‰ä½æšä¸¾ï¼›
Equatableï¼Œå®ç°åè®®å¯ä»¥ä½¿â½¤ !=ã€== , ä¸ä¹‹ç›¸ä¼¼çš„è¿˜æœ‰ Comparableï¼›
Codableï¼Œï¼ˆæ··åˆäº† Decodable å’Œ Encodableï¼‰ï¼Œencode / init decode â½…æ³•ï¼›
1ã€å®ç°äº† Codable , å°±å¯ä»¥â½¤ç³»ç»Ÿçš„ JSONEncoder().encode â½…æ³•ï¼›
2ã€å¤„ç† ç©ºå€¼ï¼Œâ½¤å¯é€‰æŠŠ null è½¬æ¢æˆ nilï¼›
3ã€å¤„ç† â½…æ³•å±æ€§åæ˜ å°„ï¼Œé‡å†™ enum:Â  private enum CodingKeys: String, CodingKey {
case abc = â€œa_b_c"
}ï¼›
4ã€å¤„ç† ç³»ç»Ÿç±»ï¼Œå¦‚ CLLocationCoordinate2Dï¼Œåœ¨ extension ä¸­å®ç° Codableï¼›
Sequence / IteratorProtocolï¼Œå®ç°äº†å¯ä»¥ä½¿â½¤ for â€¦ in ï¼Œç±»ä¼¼é“¾è¡¨ç»“æ„ï¼ŒIteratorProtocol ä¸­åŒ…å« next() â½…æ³•ï¼Œå’Œ
currentIndex â½…æ³•ï¼›ï¼ˆä¸‹â½‚ Sequence éƒ¨åˆ†æœ‰æ›´è¯¦ç»†çš„è¯´æ˜ï¼‰
Collectionï¼š
åœ¨ Sequence çš„åŸºç¡€ä¸Šï¼Œå®ç°äº†ä¸‹æ ‡â½…æ³• Indexï¼Œéµå®ˆ Comparable åè®®ï¼›
IndexingIteratorï¼Œç±»ä¼¼ IteratorProtocolï¼›
ï¼ˆä¸‹â½‚ Sequence éƒ¨åˆ†æœ‰æ›´è¯¦ç»†çš„è¯´æ˜ï¼‰

![](../assets/16911996385220.jpg)


## **é—­åŒ…ï¼š**

## Closure in Swift

 
![](../assets/16911996525270.jpg)


![](../assets/16911996457612.jpg)


## Swift çš„é—­åŒ…ï¼ˆClosureï¼‰ å’Œ OC çš„ Block
![](../assets/closure_vs_block/banner.jpg)

![](../assets/closure_vs_block/closure_vs_block_map.jpg)

æœ¬è´¨ä¸Š OC çš„ block å°±æ˜¯â¼€ä¸ªç»“æ„ä½“ï¼Œç„¶åè¿™ä¸ªç»“æ„ä½“â¾¥â¾¯æœ‰â¼€ä¸ªç»“æ„ä½“æˆå‘˜ä¸“â»”â½¤æ¥ä¿å­˜æ•æ‰å¯¹è±¡ï¼Œå› æ­¤æ‰ä¼šå¯¼è‡´
è¢« block æ•æ‰å¼•â½¤ +1Â  ï¼Œæˆ–è€…è¯´ block æ˜¯â¼€ä¸ªå¸¦æœ‰â¾ƒåŠ¨å˜é‡ï¼ˆå±€éƒ¨å˜é‡ï¼‰çš„åŒ¿åå‡½æ•°ã€‚
Block çš„åŸç†åŠå…¶å†…å­˜ç®¡ç†
Swift çš„é—­åŒ…ï¼šï¼ˆé—­åŒ…æ˜¯â¼€ä¸ªæ•è·äº†å…¨å±€ä¸Šä¸‹â½‚çš„å¸¸é‡æˆ–è€…å˜é‡çš„å‡½æ•°ï¼‰
1ã€æ•è·å€¼åŸç†ï¼šåœ¨å †ä¸Šå¼€è¾Ÿå†…å­˜ç©ºé—´ï¼Œå¹¶å°†æ•è·çš„å€¼æ”¾åˆ°è¿™ä¸ªå†…å­˜ç©ºé—´â¾¥
2ã€ä¿®æ”¹æ•è·å€¼æ—¶ï¼šå®è´¨æ˜¯ä¿®æ”¹å †ç©ºé—´çš„å€¼
3ã€é—­åŒ…æ˜¯â¼€ä¸ªå¼•â½¤ç±»å‹ï¼ˆå¼•â½¤ç±»å‹æ˜¯åœ°å€ä¼ é€’ï¼‰ï¼Œé—­åŒ…çš„åº•å±‚ç»“æ„ï¼ˆæ˜¯ç»“æ„ä½“ï¼šå‡½æ•°åœ°å€ + æ•è·å˜é‡çš„åœ°å€ == é—­åŒ…ï¼‰
4ã€å‡½æ•°ä¹Ÿæ˜¯â¼€ä¸ªå¼•â½¤ç±»å‹ï¼ˆæœ¬è´¨æ˜¯â¼€ä¸ªç»“æ„ä½“ï¼Œå…¶ä¸­åªä¿å­˜äº†å‡½æ•°çš„åœ°å€ï¼‰

å‚è€ƒ: [ã€ŠSwift-è¿›é˜¶ 09ï¼šé—­åŒ…ï¼ˆâ¼€ï¼‰ä½¿â½¤&æ•è·åŸç†ã€‹](https://www.jianshu.com/p/299a9a5c5cd1) 

å…ˆçœ‹ä¸ªç»å…¸çš„é—­åŒ…ä¼˜åŒ–

```swift
results = OKRs.filter({ (s1: Int) -> Bool in
Â  Â  Â  return s1 > 90
}) //æ­£å¸¸é—­åŒ…

results = OKRs.filter({ s1 in return s1 > 90 }) //ç±»å‹æ¨æ–­
results = OKRs.filter({ s1 in s1 > 90 }) //é»˜è®¤è¿”å›å€¼
results = OKRs.filter({ $0 > 90 }) //å‚æ•°æ›¿æ¢
results = OKRs.filter{ $0 > 90 } //å°¾éšé—­åŒ…
results = OKRs.filter( $0 > 90 ) //â¾ƒåŠ¨é—­åŒ… @autoclosure // @autoclosure ä¼šæŠŠ $0 > 90 çš„è¡¨è¾¾å¼â¾ƒåŠ¨è½¬æ¢æˆ () -> T
//a ï¼Ÿï¼Ÿb ä¸­ b çš„å®ç°ä¹Ÿæ˜¯è½¬æ¢æˆäº†â¼€ä¸ªâ¾ƒåŠ¨é—­åŒ… () -> T

```

swift é—­åŒ…çš„ä¼˜åŒ–ï¼Œå°±æ˜¯ä¸Šâ¾¯çš„ä»£ç 
1.æ ¹æ®ä¸Šä¸‹â½‚æ¨æ–­å‚æ•°å’Œè¿”å›å€¼ç±»å‹
2.ä»å•â¾è¡¨è¾¾å¼é—­åŒ…ä¸­éšå¼è¿”å›ï¼ˆä¹Ÿå°±æ˜¯é—­åŒ…ä½“åªæœ‰â¼€â¾ä»£ç ï¼Œå¯ä»¥çœç•¥returnï¼‰
3.å¯ä»¥ä½¿â½¤ç®€åŒ–å‚æ•°åï¼Œå¦‚$0, $1(ä»0å¼€å§‹ï¼Œè¡¨ç¤ºç¬¬iä¸ªå‚æ•°...)
4.æä¾›äº†å°¾éšé—­åŒ…è¯­æ³•(Trailing closure syntax)

é—­åŒ…æ•è·å€¼ï¼š
é—­åŒ…å¯ä»¥åœ¨å…¶å®šä¹‰çš„ä¸Šä¸‹â½‚ä¸­æ•è·å¸¸é‡æˆ–å˜é‡ã€‚
å³ä½¿å®šä¹‰è¿™äº›å¸¸é‡å’Œå˜é‡çš„åŸåŸŸå·²ç»ä¸å­˜åœ¨ï¼Œé—­åŒ…ä»ç„¶å¯ä»¥åœ¨é—­åŒ…å‡½æ•°ä½“å†…å¼•â½¤å’Œä¿®æ”¹è¿™äº›å€¼ã€‚
Swiftæœ€ç®€å•çš„é—­åŒ…å½¢å¼æ˜¯åµŒå¥—å‡½æ•°ï¼Œä¹Ÿå°±æ˜¯å®šä¹‰åœ¨å…¶ä»–å‡½æ•°çš„å‡½æ•°ä½“å†…çš„å‡½æ•°ã€‚
åµŒå¥—å‡½æ•°å¯ä»¥æ•è·å…¶å¤–éƒ¨å‡½æ•°æ‰€æœ‰çš„å‚æ•°ä»¥åŠå®šä¹‰çš„å¸¸é‡å’Œå˜é‡ã€‚

![](../assets/closure_vs_block/closure_vs_block_question1.jpg)

```swift
//è¿™ä¸ªä¾‹â¼¦å°±æ˜¯ åµŒå¥—å‡½æ•° incrementor() çš„æœ¬è´¨æ˜¯é—­åŒ…ï¼Œ é—­åŒ…æ•è·äº† runningTotal å€¼ï¼Œå­˜å‚¨äº†èµ·æ¥ï¼Œ
æ‰€ä»¥æ¯æ¬¡è°ƒâ½¤éƒ½ä¼š + 10
func makeIncrementor(forIncrement amount: Int) -> () -> Int {
Â  Â  var runningTotal = 0
Â  Â  func incrementor() -> Int {
Â  Â  Â  Â  runningTotal += amount
Â  Â  Â  Â  return runningTotal
Â  Â  }
Â  Â  return incrementor
}

let incrementByTen = makeIncrementor(forIncrement: 10)

// è¿”å›çš„å€¼ä¸º10
print(incrementByTen())
// è¿”å›çš„å€¼ä¸º20
print(incrementByTen())
// è¿”å›çš„å€¼ä¸º30
print(incrementByTen())

```

æ‰©å±•:

![](../assets/closure_vs_block/closure_vs_block_question2.jpg)
![](../assets/closure_vs_block/closure_vs_block_question3.jpg)
## **å¯é€‰ç±»å‹ï¼š**

## What is optionals?

optional == wrapped åŒ…

when use  optional == unwrapped è§£åŒ…
![](../assets/16911996627336.jpg)


[Difference between optional values in swift?](https://stackoverflow.com/a/29054155/3395008)
![](../assets/16911996707498.jpg)


Swift 5.7 introduces a new, more concise way to unwrap optional values usingÂ `if let`Â andÂ `guard let`Â statements. Before, we always had to explicitly name each unwrapped value, for example like this:

[Swift 5.7â€™s new optional unwrapping syntax | Swift by Sundell](https://www.swiftbysundell.com/articles/swifts-new-shorthand-optional-unwrapping-syntax/)
![](../assets/16911996765839.jpg)

![](../assets/16911996818935.jpg)


1. 4. What is the difference between if let and guard let?

## *8ã€Optionalï¼ˆå¯é€‰å‹ï¼‰ æ˜¯â½¤ä»€ä¹ˆå®ç°çš„*

*ä½¿â½¤æšä¸¾ï¼ˆenumï¼‰çš„å…³è”å€¼ ç‰¹æ€§å®ç°çš„ã€‚
1ï¼‰æšä¸¾çš„å…³è”å€¼å’ŒåŸå§‹å€¼ï¼š
åŸå§‹å€¼ï¼š å°±æ˜¯ rawValue
å…³è”å€¼ï¼šç±»ä¼¼ä¸ä¸‹â½‚ Optional some çš„â½¤æ³•ï¼Œå¯ä»¥æ ¹æ®ä¸åŒæšä¸¾ç±»å‹åˆ›å»ºä¸åŒçš„æšä¸¾ã€‚Alamoï¬re çš„å›è°ƒä¹Ÿæ˜¯è¿™ä¹ˆâ½¤çš„ã€‚
2ï¼‰Optional æºç ï¼š*

```swift
*1"//ä½¿â½¤æšä¸¾ï¼ŒWrapped çš„è‹±â½‚æ˜¯ ä½¿""...åŒ…è£¹çš„æ„æ€
2enum Optional<Wrapped> {
3Â  case none
4Â  case some(Wrapped)
5}
6
7"//è¿™æ˜¯ä¸ªè¯­æ³•ç³–ï¼Œä¸‹â¾¯ä¸¤ç§å½¢å¼ç­‰ä»·ï¼š
8var name: Optional<String>
9var name: String?*

```

*1ï¼‰ ! æˆ–è€… ï¼Ÿæ‹†åŒ…Â Â 
æ‰€è°“çš„ nil å°±æ˜¯ Optional.NoneÂ 
ä½¿â½¤çš„æ—¶å€™åéœ€è¦ä½¿â½¤ ! æ¥ä» enum â¾¥è¿›â¾æ‹†åŒ…Â 
ï¼â½¤æ¥æ±‚å– Optional.Some(T) åŒ…è£…ä¸‹çš„å€¼ï¼Œæ‰€ä»¥ä¸º Optional å€¼ = nil æ—¶ä¼šæŠ¥é”™ï¼› -> è¿™â¾¥å¯ä»¥å¼•å‡ºæ³›å‹ç›¸å…³é—®é¢˜*

*2ï¼‰ å¯é€‰é“¾
a?.b?.cï¼Œå¦‚æœå‰â¾¯çš„ä¸º nil äº†åˆ™ç»“æœç›´æ¥ä¸º nilï¼›*

*3ï¼‰?? æ¥è¡¨ç¤ºé»˜è®¤å€¼
4ï¼‰é™¤äº† ! / ï¼Ÿ æ‹†åŒ…ï¼Œè¿˜æœ‰ if let å¯é€‰ç»‘å®šã€éšå¼è§£æï¼ˆaï¼= xxxxï¼‰ä¸¤ç§å¤„ç† Optional çš„å½¢å¼ï¼›*

#### 4. How to unwrap optionals in Swift?
https://www.hackingwithswift.com/sixty/10/2/unwrapping-optionals


## *lazy load æ˜¯æ€ä¹ˆå®ç°çš„ï¼Ÿ*
![](assets/16914714232134.jpg)

è¯·è§£é‡Š Swift ä¸­çš„ lazy å…³é”®å­—æ˜¯æ€ä¹ˆå®ç°çš„ï¼Ÿåœ¨ä»€ä¹ˆæƒ…å†µä¸‹ä¼šä½¿ç”¨å®ƒï¼Ÿ

*Swift çš„ lazy åˆ†ï¼š

1ã€lazy ä¿®é¥°å±æ€§ï¼ˆâ»…ä¸Šâ¼€æ¡ï¼‰ï¼›
2ã€lazy ä¿®é¥°â½…æ³•ï¼ˆâ»…ä¸Šâ¼€æ¡ï¼‰ï¼›
3ã€collection ä¸­çš„ lazyï¼š
æŠŠ Sequence æ›¿æ¢æˆäº† ä¸ª LazySequenceï¼ˆå®ç° SequenceWrapper æ¥â¼ï¼‰ï¼›
SequenceWrapper ä¿å­˜äº†åŸå§‹åºåˆ—å’Œå˜æ¢ï¼ˆtransformï¼‰ï¼›
LazySequenceÂ  çš„ Interator åœ¨ next() â½…æ³•ä¸­ï¼Œå®ç°äº†å»¶è¿Ÿè°ƒâ½¤å˜æ¢ï¼ˆtransformï¼‰ï¼›*



------

<p align="center"><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/02_Swift_interview_questions/practical.md"><img src="../assets/Swift_practical_Interview_Questions.jpg"></a></p>
